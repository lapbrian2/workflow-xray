---
phase: 02-team-size-aware-analysis
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/team-calibration.ts
  - src/lib/types.ts
  - src/lib/scoring.ts
  - src/lib/decompose.ts
autonomous: true

must_haves:
  truths:
    - "computeHealth() with no teamSize returns identical scores to the current formula (backward compatible)"
    - "computeHealth() with teamSize=3 returns visibly different fragility and teamLoadBalance scores than teamSize=50 for the same steps/gaps"
    - "getTeamTier() classifies 1 as solo, 3 as small, 10 as medium, 25 as large"
    - "HealthMetrics type has optional teamSize and confidence fields"
    - "Gap type has optional confidence field"
    - "decomposeWorkflow() accepts optional teamSize parameter and passes it to computeHealth()"
  artifacts:
    - path: "src/lib/team-calibration.ts"
      provides: "Team tier classification and threshold multipliers"
      exports: ["getTeamTier", "getThresholds", "TeamTier", "TeamThresholds"]
    - path: "src/lib/scoring.ts"
      provides: "Team-size-aware health computation"
      exports: ["computeHealth"]
    - path: "src/lib/types.ts"
      provides: "Extended HealthMetrics and Gap types with confidence"
      contains: "confidence"
    - path: "src/lib/decompose.ts"
      provides: "teamSize parameter threading to computeHealth"
      contains: "teamSize"
  key_links:
    - from: "src/lib/scoring.ts"
      to: "src/lib/team-calibration.ts"
      via: "import getThresholds"
      pattern: "getThresholds"
    - from: "src/lib/decompose.ts"
      to: "src/lib/scoring.ts"
      via: "computeHealth(steps, gaps, teamSize)"
      pattern: "computeHealth.*teamSize"
---

<objective>
Build the team-size-aware scoring engine with TDD: team tier classification, threshold multipliers, and updated health computation that produces different scores based on team capacity.

Purpose: This is the computational backbone of Phase 2. Without team-calibrated scoring, the same workflow analyzed at team size 3 vs 50 would produce identical health metrics, failing Success Criteria #2.

Output: Working, tested team calibration module + updated scoring + type extensions. All backward compatible -- no teamSize = identical scores.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-team-size-aware-analysis/02-RESEARCH.md

@src/lib/scoring.ts
@src/lib/types.ts
@src/lib/decompose.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create team-calibration module and extend types</name>
  <files>
    src/lib/team-calibration.ts
    src/lib/types.ts
  </files>
  <action>
Create `src/lib/team-calibration.ts` with:

1. `TeamTier` type: `"solo" | "small" | "medium" | "large"`

2. `getTeamTier(teamSize: number): TeamTier` function:
   - teamSize <= 1 -> "solo"
   - teamSize <= 5 -> "small"
   - teamSize <= 20 -> "medium"
   - teamSize > 20 -> "large"

3. `TeamThresholds` interface with:
   - `fragilityMultiplier: number` (amplifies fragility score for smaller teams)
   - `bottleneckMultiplier: number` (amplifies bottleneck impact for smaller teams)
   - `loadBalanceBaseline: number` (adjusts expected balance baseline)

4. `THRESHOLDS` constant: `Record<TeamTier, TeamThresholds>`:
   - solo: { fragilityMultiplier: 1.8, bottleneckMultiplier: 1.5, loadBalanceBaseline: 30 }
   - small: { fragilityMultiplier: 1.4, bottleneckMultiplier: 1.3, loadBalanceBaseline: 50 }
   - medium: { fragilityMultiplier: 1.0, bottleneckMultiplier: 1.0, loadBalanceBaseline: 60 }
   - large: { fragilityMultiplier: 0.8, bottleneckMultiplier: 0.8, loadBalanceBaseline: 70 }

5. `getThresholds(teamSize?: number): TeamThresholds` function:
   - If teamSize is undefined or null, return THRESHOLDS.medium (the baseline -- multiplier 1.0 means no change, backward compatible)
   - Otherwise return THRESHOLDS[getTeamTier(teamSize)]

Then update `src/lib/types.ts`:

6. Add `ConfidenceLevel` type: `"high" | "inferred"`

7. Add optional fields to `HealthMetrics` interface:
   - `teamSize?: number` -- stores the team size used for calibration
   - `confidence?: { level: ConfidenceLevel; reason: string }` -- indicates whether scores are calibrated or using defaults

8. Add optional `confidence` field to `Gap` interface:
   - `confidence?: ConfidenceLevel` -- per-gap confidence indicator

IMPORTANT: All new fields MUST be optional (using `?`) to maintain backward compatibility with stored workflows that lack these fields.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Check that existing code that imports HealthMetrics and Gap compiles without changes.
  </verify>
  <done>
team-calibration.ts exports getTeamTier, getThresholds, TeamTier, TeamThresholds. types.ts has ConfidenceLevel, HealthMetrics.teamSize, HealthMetrics.confidence, and Gap.confidence -- all optional. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update computeHealth() and decomposeWorkflow() with team-size threading</name>
  <files>
    src/lib/scoring.ts
    src/lib/decompose.ts
  </files>
  <action>
Update `src/lib/scoring.ts`:

1. Add `teamSize?: number` as a third parameter to `computeHealth()`.

2. Import `getThresholds` from `./team-calibration`.

3. At the start of computeHealth, call `const thresholds = getThresholds(teamSize)`.

4. Apply `thresholds.fragilityMultiplier` to the fragility score BEFORE the Math.min(100, ...) clamp:
   - Current: `fragility = Math.min(100, Math.round(highSeverityGaps * 20 + mediumSeverityGaps * 10 + singleDepGaps * 15 + lowAutoSteps * 5))`
   - New: Compute the raw score first, then: `fragility = Math.min(100, Math.round(rawFragility * thresholds.fragilityMultiplier))`

5. For `teamLoadBalance`: when owners.length === 0 (no ownership assigned), use `thresholds.loadBalanceBaseline` instead of hardcoded 50. When uniqueOwners === 1, use `Math.min(thresholds.loadBalanceBaseline, Math.round(100 / owners.length))` instead of `Math.min(30, ...)`.

6. Add teamSize and confidence to the return value:
   ```
   return {
     complexity,
     fragility,
     automationPotential: avgAutomation,
     teamLoadBalance,
     ...(teamSize !== undefined ? { teamSize } : {}),
     confidence: teamSize !== undefined
       ? { level: "high" as const, reason: "Team size was explicitly provided" }
       : { level: "inferred" as const, reason: "No team size specified; using medium-team defaults" },
   };
   ```

CRITICAL: When teamSize is undefined, getThresholds returns medium defaults (multiplier 1.0), which means the scores are computed identically to the current formula. This ensures backward compatibility.

Update `src/lib/decompose.ts`:

7. Add `teamSize?: number` as a second parameter to `decomposeWorkflow()`:
   ```
   export async function decomposeWorkflow(
     request: DecomposeRequest,
     teamSize?: number
   ): Promise<Decomposition & { _meta: DecomposeMetadata }>
   ```

8. Pass teamSize to `computeHealth()`:
   - Change: `const health = computeHealth(validated.steps, cleanGaps);`
   - To: `const health = computeHealth(validated.steps, cleanGaps, teamSize);`
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles. Manually verify that the scoring.ts changes only apply multipliers when teamSize is passed, and default to 1.0 otherwise. Run the app locally if possible: `npm run dev` and submit a workflow without team size to confirm unchanged behavior.
  </verify>
  <done>
computeHealth() accepts teamSize, applies team-tier multipliers to fragility and teamLoadBalance, and returns identical scores when teamSize is undefined. decomposeWorkflow() accepts teamSize and threads it to computeHealth(). TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Existing code importing HealthMetrics, Gap, computeHealth, or decomposeWorkflow compiles without modification (no required field additions)
3. Calling `computeHealth(steps, gaps)` (no teamSize) returns the same scores as the original formula
4. Calling `computeHealth(steps, gaps, 3)` returns higher fragility than `computeHealth(steps, gaps, 50)` for the same steps/gaps
</verification>

<success_criteria>
- team-calibration.ts exists and exports team tier classification + threshold multipliers
- types.ts has ConfidenceLevel, optional confidence on HealthMetrics and Gap
- scoring.ts applies team-size multipliers to fragility and teamLoadBalance
- decompose.ts passes teamSize parameter through to computeHealth
- Zero TypeScript errors
- Backward compatibility: no teamSize = identical scores to pre-change behavior
</success_criteria>

<output>
After completion, create `.planning/phases/02-team-size-aware-analysis/02-01-SUMMARY.md`
</output>
