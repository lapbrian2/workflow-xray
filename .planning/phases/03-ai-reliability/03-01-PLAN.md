---
phase: 03-ai-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/claude.ts
  - src/lib/decompose.ts
autonomous: true

must_haves:
  truths:
    - "When Claude API returns a transient 429 or 5xx error, the SDK automatically retries up to 3 times with exponential backoff before surfacing an error"
    - "When Claude returns malformed JSON, the app recovers whatever partial data is valid instead of throwing a full error"
    - "When partial recovery produces steps but no gaps, the result includes a _partial flag so downstream consumers know the data is incomplete"
  artifacts:
    - path: "src/lib/claude.ts"
      provides: "Anthropic client with maxRetries=3, per-call timeout, typed error exports"
      contains: "maxRetries"
    - path: "src/lib/decompose.ts"
      provides: "Partial JSON recovery with safeParse, _partial flag, recoverPartialDecomposition function"
      contains: "recoverPartialDecomposition"
  key_links:
    - from: "src/lib/claude.ts"
      to: "@anthropic-ai/sdk"
      via: "maxRetries config on Anthropic client constructor"
      pattern: "maxRetries:\\s*3"
    - from: "src/lib/decompose.ts"
      to: "src/lib/decompose.ts"
      via: "safeParse replaces parse for Zod validation"
      pattern: "safeParse"
    - from: "src/lib/decompose.ts"
      to: "src/lib/decompose.ts"
      via: "recoverPartialDecomposition provides fallback when safeParse fails"
      pattern: "recoverPartialDecomposition"
---

<objective>
Make Claude API calls resilient to transient failures and malformed output. This plan configures SDK-level retry with exponential backoff (AIRE-01) and adds partial JSON recovery to the decompose pipeline (AIRE-02), so the app degrades gracefully instead of showing full error pages.

Purpose: Transient Claude API failures (429 rate limits, 5xx server errors, timeouts) currently surface as user-facing errors on the first failure. Malformed JSON responses crash the decompose pipeline entirely. This plan fixes both.
Output: Updated claude.ts with retry config + typed error re-exports. Updated decompose.ts with multi-strategy JSON extraction, Zod safeParse, and partial recovery function.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-reliability/03-RESEARCH.md

@src/lib/claude.ts
@src/lib/decompose.ts
@src/lib/extraction-schemas.ts
@src/lib/api-errors.ts
@src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure SDK retry and export typed error classes</name>
  <files>src/lib/claude.ts</files>
  <action>
Modify the Anthropic client instantiation in src/lib/claude.ts to enable automatic retry with exponential backoff:

1. Update the `new Anthropic({...})` constructor to add `maxRetries: 3`. This makes the SDK automatically retry connection errors, 408, 409, 429, and >=500 responses with exponential backoff and jitter. Keep the existing `apiKey` config.

2. For each `callClaude*` function (callClaude, callClaudeExtraction, callClaudeRemediation, callClaudeVisionExtraction), ensure the per-request options include `timeout: 45_000` (already present as the second arg). No change needed here -- the existing `{ timeout: 45000 }` works. The SDK will retry each attempt with its own 45s timeout. Worst case with maxRetries=3 is ~3 minutes total (4 attempts with backoff).

3. Re-export the Anthropic SDK error classes for use by downstream route handlers. Add at the bottom of the file:
```typescript
// Re-export SDK error types for typed catch blocks in route handlers
export {
  APIError as ClaudeAPIError,
  RateLimitError as ClaudeRateLimitError,
  APIConnectionError as ClaudeConnectionError,
  APIConnectionTimeoutError as ClaudeTimeoutError,
} from "@anthropic-ai/sdk";
```

NOTE: The actual re-export syntax depends on how the SDK exports these. Check `@anthropic-ai/sdk` -- the error classes are exported from the main module as properties of the default export (e.g., `Anthropic.RateLimitError`). Since route handlers need `instanceof` checks, export the classes as named exports so consumers can do `import { ClaudeRateLimitError } from "@/lib/claude"` and use `error instanceof ClaudeRateLimitError`.

If the SDK does not support named exports for error classes (i.e., they are only accessible as `Anthropic.RateLimitError`), instead export a helper function:
```typescript
import Anthropic from "@anthropic-ai/sdk";

export function classifyClaudeError(error: unknown): {
  type: "rate_limit" | "timeout" | "connection" | "api_error" | "unknown";
  status: number | null;
  retryable: boolean;
} {
  if (error instanceof Anthropic.RateLimitError) {
    return { type: "rate_limit", status: 429, retryable: false }; // SDK already exhausted retries
  }
  if (error instanceof Anthropic.APIConnectionTimeoutError) {
    return { type: "timeout", status: null, retryable: false };
  }
  if (error instanceof Anthropic.APIConnectionError) {
    return { type: "connection", status: null, retryable: false };
  }
  if (error instanceof Anthropic.APIError) {
    return { type: "api_error", status: (error as Anthropic.APIError).status ?? null, retryable: false };
  }
  return { type: "unknown", status: null, retryable: false };
}
```

This avoids forcing downstream code to import from `@anthropic-ai/sdk` directly and centralizes error classification.

Do NOT wrap the SDK in another retry layer. The SDK handles all retry logic internally.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- no TypeScript errors in claude.ts or files importing from it.
2. Grep for `maxRetries` in claude.ts -- should find exactly one occurrence with value 3.
3. Grep for `classifyClaudeError` in claude.ts -- should be exported.
  </verify>
  <done>
Anthropic client configured with maxRetries=3. All callClaude* functions inherit automatic retry on transient failures. A classifyClaudeError helper is exported for typed error handling in route handlers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add partial JSON recovery to decompose pipeline</name>
  <files>src/lib/decompose.ts</files>
  <action>
Refactor decomposeWorkflow() in src/lib/decompose.ts to gracefully handle malformed Claude output instead of throwing hard errors. Follow the proven pattern from src/lib/extraction-schemas.ts (parseExtractionJson + recoverPartialExtraction).

1. Add a `_partial` flag to the return type. Update the DecomposeMetadata section -- add a new interface:
```typescript
export interface PartialDecompositionInfo {
  _partial: boolean;
  _recoveryReason?: string;
}
```
Update the return type of decomposeWorkflow to include this: `Promise<Decomposition & { _meta: DecomposeMetadata } & PartialDecompositionInfo>`.

Also update the Decomposition type in src/lib/types.ts if needed -- but prefer NOT modifying types.ts. Instead, extend the return type locally in decompose.ts and let consumers check for the `_partial` property optionally.

ACTUALLY: DO NOT modify types.ts. The `_partial` and `_recoveryReason` fields should be added to the return object of decomposeWorkflow only. The route handler (which will be updated in Plan 02) will thread these into the workflow response.

2. Replace the hard JSON.parse try/catch block (lines 104-118) with a multi-strategy extraction function. Create a local function `extractJsonFromResponse(raw: string): unknown | null`:
   - Strategy 1: Code fence extraction -- `raw.match(/```(?:json)?\s*([\s\S]*?)```/)`, then JSON.parse the inner content
   - Strategy 2: Direct JSON.parse on the full string
   - Strategy 3: Find largest JSON object -- `raw.match(/\{[\s\S]*\}/)`, then JSON.parse
   - Return null if all strategies fail (do NOT throw)

   This mirrors the pattern in parseExtractionJson from extraction-schemas.ts.

3. Replace the hard Zod `.parse()` call (line 122) with `.safeParse()`:
```typescript
const zodResult = DecompositionResponseSchema.safeParse(parsed);
let validated;
let isPartial = false;
let recoveryReason: string | undefined;

if (zodResult.success) {
  validated = zodResult.data;
} else {
  // Attempt partial recovery
  const recovered = recoverPartialDecomposition(parsed);
  validated = recovered;
  isPartial = true;
  recoveryReason = recovered._recoveryReason;
}
```

4. Add the `recoverPartialDecomposition(raw: unknown)` function. It should:
   - Cast raw to Record<string, unknown>
   - Extract title: string (default "Untitled Analysis")
   - Extract steps array: for each element, safely extract id (default `step_{i+1}`), name (default `Step {i+1}`), description (default ""), owner (default null), layer (validate against enum, default "human"), inputs/outputs/tools (filter to string arrays), automationScore (clamp 0-100, default 50), dependencies (filter to string arrays). Skip elements that are not objects.
   - Extract gaps array: for each element, safely extract type (default "manual_overhead"), severity (validate against enum, default "medium"), stepIds (filter to string arrays), description (default ""), suggestion (default ""), confidence (default "inferred"). Skip elements that are not objects or have empty description.
   - Return `{ title, steps, gaps, _partial: true, _recoveryReason: "Recovered N steps and M gaps from malformed response" }`

   Follow the exact pattern of recoverPartialExtraction in extraction-schemas.ts but adapted for the decomposition schema.

5. Handle the total-failure case (extractJsonFromResponse returns null):
```typescript
const parsed = extractJsonFromResponse(raw);
if (parsed === null) {
  // Build a minimal result with just the title from the request
  const minTitle = request.description.slice(0, 80).replace(/\n/g, " ").trim() || "Failed Analysis";
  const health = computeHealth([], [], teamSize);
  return {
    id: generateId(),
    title: minTitle,
    steps: [],
    gaps: [],
    health,
    _meta: { promptVersion: getPromptVersion(), modelUsed: getModelId(), inputTokens: response.inputTokens, outputTokens: response.outputTokens },
    _partial: true,
    _recoveryReason: "Could not extract any valid JSON from Claude response",
  };
}
```

6. After validation (whether full or partial), the existing referential integrity checks (dedup step IDs, fix invalid dependency refs, fix invalid gap stepIds, filter orphan gaps, break cycles, clamp automation scores) MUST still run on the recovered data. Do NOT skip these -- they are critical for downstream rendering stability. Just pass the recovered `validated` object through the same pipeline.

7. Include `_partial: isPartial` and `_recoveryReason: recoveryReason` in the final return object alongside the existing fields.

Do NOT import from extraction-schemas.ts. The decomposition schema is different enough that the recovery function should be self-contained in decompose.ts. The pattern is the same; the fields differ.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- no TypeScript errors.
2. Grep for `safeParse` in decompose.ts -- should find at least one occurrence (replacing the old `.parse()` call).
3. Grep for `recoverPartialDecomposition` in decompose.ts -- should be defined.
4. Grep for `_partial` in decompose.ts -- should appear in the return object.
5. Confirm the old hard-throw patterns are gone: grep for `throw new Error.*invalid JSON` and `throw new Error.*schema validation` in decompose.ts -- should find zero matches.
  </verify>
  <done>
decomposeWorkflow() uses multi-strategy JSON extraction (code fence, direct parse, object extraction). Zod validation uses safeParse with partial recovery fallback. Total parse failure returns a minimal result with _partial=true. All recovered data passes through existing referential integrity checks. No hard throws on malformed Claude output.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes with zero errors
2. Retry config: `maxRetries: 3` present in claude.ts Anthropic constructor
3. Error classification: `classifyClaudeError` exported from claude.ts
4. Partial recovery: `recoverPartialDecomposition` defined in decompose.ts
5. No hard throws: decompose.ts no longer throws on JSON parse or Zod validation failure
6. Referential integrity: recovered data still passes through dedup, dependency fix, cycle detection, and score clamping
</verification>

<success_criteria>
- Anthropic SDK retries transient failures 3 times automatically with exponential backoff
- Malformed Claude JSON output triggers partial recovery instead of error page
- Total JSON extraction failure returns minimal result with _partial=true flag
- All existing decompose functionality unchanged for well-formed responses
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-reliability/03-01-SUMMARY.md`
</output>
