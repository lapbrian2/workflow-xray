---
phase: 05-debt-closure-test-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["05-02"]
files_modified:
  - __tests__/lib/decompose.test.ts
  - src/lib/claude.ts
  - playwright.config.ts
  - e2e/submit-workflow.spec.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Unit tests for decompose pipeline cover JSON extraction, partial recovery, Zod validation, and referential integrity"
    - "Decompose tests use MSW to intercept Claude API at network level (not function-level mocks)"
    - "Playwright E2E test submits a workflow, observes SSE progress, views results page, and exports PDF"
    - "E2E test runs without hitting the real Claude API (MOCK_CLAUDE=true toggle)"
    - "Running npx playwright test executes and passes the E2E test"
  artifacts:
    - path: "__tests__/lib/decompose.test.ts"
      provides: "Unit tests for decomposeWorkflow pipeline"
      contains: "decomposeWorkflow"
    - path: "src/lib/claude.ts"
      provides: "MOCK_CLAUDE env toggle that returns mock response without API call"
      contains: "MOCK_CLAUDE"
    - path: "playwright.config.ts"
      provides: "Playwright configuration with webServer auto-start"
      contains: "defineConfig"
    - path: "e2e/submit-workflow.spec.ts"
      provides: "E2E test for full submit-analyze-view-export flow"
      contains: "test.*workflow"
  key_links:
    - from: "__tests__/lib/decompose.test.ts"
      to: "__tests__/mocks/server.ts"
      via: "MSW server intercepts Anthropic API during decompose tests"
      pattern: "server"
    - from: "src/lib/claude.ts"
      to: "e2e/submit-workflow.spec.ts"
      via: "MOCK_CLAUDE=true env var bypasses real API in E2E"
      pattern: "MOCK_CLAUDE"
    - from: "playwright.config.ts"
      to: "package.json"
      via: "webServer runs npm run dev with MOCK_CLAUDE=true"
      pattern: "webServer"
---

<objective>
Complete the test suite with decompose pipeline unit tests using MSW and a Playwright E2E test covering the full submit-analyze-view-export critical path, all running without real API calls.

Purpose: The decompose pipeline is the most critical business logic path (JSON extraction, partial recovery, validation, referential integrity). E2E tests verify the entire user flow works end-to-end. Together with plan 05-02's unit tests, this completes the test safety net for all subsequent v1.1 work.
Output: Decompose pipeline test suite, MOCK_CLAUDE toggle in claude.ts, Playwright config, and E2E test spec.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-debt-closure-test-infrastructure/05-02-SUMMARY.md
@src/lib/decompose.ts
@src/lib/claude.ts
@src/lib/types.ts
@src/app/api/decompose/route.ts
@__tests__/mocks/handlers.ts
@__tests__/mocks/fixtures.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Decompose pipeline unit tests with MSW</name>
  <files>__tests__/lib/decompose.test.ts, __tests__/mocks/handlers.ts</files>
  <action>
Create `__tests__/lib/decompose.test.ts` testing the `decomposeWorkflow` function from `@/lib/decompose`. This function calls Claude via `callClaude` which MSW intercepts at the network level.

IMPORTANT: The decompose module imports from `@/lib/claude` which reads prompt files from disk using `fs.readFileSync`. For tests, ensure the prompts directory exists and is accessible. The function tries multiple paths including `{cwd}/prompts/decompose-system.md`. If the prompt file is not found, `callClaude` will throw. To handle this:
- Option A: The test setup can use `server.use()` to override the handler -- but the prompt loading happens BEFORE the API call. We need the prompt files to exist.
- Option B: Mock the `loadPrompt` function -- but we want to test the full pipeline at the network level, not mock internals.
- Option C: The prompts directory already exists at `prompts/` in the project root. As long as tests run from the project root (which Vitest does by default), `readFileSync` will find them. Verify this by checking that `prompts/decompose-system.md` exists.

The MSW server (from plan 05-02) intercepts `https://api.anthropic.com/v1/messages` and returns mock Claude responses. Tests exercise the FULL pipeline: callClaude -> extractJsonFromResponse -> Zod validation -> referential integrity -> computeHealth.

Test cases:

a. **Happy path - valid response**: Default MSW handler returns valid JSON. Call `decomposeWorkflow({ description: "Test workflow" })`. Verify result has: id (string), title (from fixture), steps array with correct count, gaps array, health scores computed, `_partial` is false.

b. **Partial recovery - malformed JSON**: Use `server.use()` to override handler for this test. Return a Claude response where the JSON has an invalid step layer (e.g., "unknown_layer") and a missing gap field. Verify result has `_partial: true`, `_recoveryReason` is a non-empty string, steps are recovered with default layer, and health is still computed.

c. **Total failure - no JSON in response**: Override handler to return plain text with no JSON at all (e.g., "I cannot analyze this workflow"). Verify result has `_partial: true`, `_recoveryReason` contains "Could not extract", steps is empty array, gaps is empty array.

d. **Referential integrity - duplicate step IDs**: Override handler to return steps with duplicate IDs. Verify duplicates are removed (only first occurrence kept).

e. **Referential integrity - invalid dependency references**: Override handler to return a step with a dependency on a non-existent step ID. Verify the invalid dependency is removed from the step's dependencies array.

f. **Referential integrity - self-referencing dependency**: Override handler to return a step that depends on itself. Verify the self-reference is removed.

g. **Circular dependency detection**: Override handler to return steps A->B->C->A circular dependency. Verify one edge is removed to break the cycle. Verify no error is thrown.

h. **Team size integration**: Call `decomposeWorkflow(request, 3)` (small team). Verify health scores use small-team thresholds (fragilityMultiplier=1.4). Compare fragility against calling with teamSize=10 (medium, multiplier=1.0) -- small team should have higher fragility.

i. **Code fence extraction**: Override handler to return JSON wrapped in ```json ... ``` code fences. Verify extraction succeeds.

j. **Direct JSON extraction**: Override handler to return raw JSON (no code fence). Verify extraction succeeds.

For tests that override handlers, use the pattern:
```typescript
server.use(
  http.post("https://api.anthropic.com/v1/messages", () => {
    return HttpResponse.json({
      // ... custom response
    });
  })
);
```

Import `http` and `HttpResponse` from "msw", and `server` from "../mocks/server".
  </action>
  <verify>Run `npx vitest run __tests__/lib/decompose.test.ts` -- all tests pass. The tests should take a few seconds (MSW responds instantly, no real API calls).</verify>
  <done>Decompose pipeline has 10 test cases covering happy path, partial recovery, total failure, referential integrity (duplicates, invalid deps, self-refs, cycles), team size integration, and JSON extraction strategies -- all using MSW network-level interception.</done>
</task>

<task type="auto">
  <name>Task 2: MOCK_CLAUDE toggle, Playwright config, and E2E test</name>
  <files>src/lib/claude.ts, playwright.config.ts, e2e/submit-workflow.spec.ts, package.json</files>
  <action>
1. **Add MOCK_CLAUDE toggle to `src/lib/claude.ts`**:

   At the top of the file (after existing imports and before the client instantiation), add a mock response function. The research recommended this pattern because MSW cannot intercept server-side fetch in Playwright's context (the Next.js server runs in a separate process).

   Add this block after the `LOG_TOKENS` constant (around line 11):

   ```typescript
   const MOCK_CLAUDE = process.env.MOCK_CLAUDE === "true";
   ```

   Modify the `callClaude` function: at the very beginning (before `const response = await client.messages.create`), add:

   ```typescript
   if (MOCK_CLAUDE) {
     const mockResponse = JSON.stringify({
       title: "Mock Workflow Analysis",
       steps: [
         { id: "step_1", name: "Receive Request", description: "Initial request intake", owner: "Operator", layer: "human", inputs: ["request"], outputs: ["ticket"], tools: ["email"], automationScore: 30, dependencies: [] },
         { id: "step_2", name: "Process Data", description: "Transform and validate data", owner: "System", layer: "orchestration", inputs: ["ticket"], outputs: ["processed_data"], tools: ["script"], automationScore: 85, dependencies: ["step_1"] },
         { id: "step_3", name: "Review Output", description: "Human review of processed results", owner: "Manager", layer: "human", inputs: ["processed_data"], outputs: ["approved_output"], tools: ["dashboard"], automationScore: 20, dependencies: ["step_2"] },
       ],
       gaps: [
         { type: "bottleneck", severity: "high", stepIds: ["step_3"], description: "Manager review creates delays", suggestion: "Add auto-approval for low-risk items", confidence: "high" },
         { type: "manual_overhead", severity: "medium", stepIds: ["step_1"], description: "Manual request intake", suggestion: "Implement web form submission", confidence: "inferred" },
       ],
     });
     return {
       text: "```json\n" + mockResponse + "\n```",
       inputTokens: 500,
       outputTokens: 300,
     };
   }
   ```

   Apply the same pattern to `callClaudeExtraction` and `callClaudeRemediation` -- add a `MOCK_CLAUDE` early return with minimal valid responses. For extraction, return a simple extracted workflow JSON. For remediation, return a simple remediation plan JSON. These can be simpler since the E2E test focuses on the decompose flow.

   IMPORTANT: Do NOT modify any other behavior. The existing production code paths remain unchanged when `MOCK_CLAUDE` is unset or false.

2. **Install Playwright**:
   Run: `npm install -D @playwright/test`
   Then: `npx playwright install chromium` (install only Chromium browser, not all browsers)

3. **Create `playwright.config.ts`** at project root:

   ```typescript
   import { defineConfig } from "@playwright/test";

   export default defineConfig({
     testDir: "./e2e",
     fullyParallel: false,
     retries: 0,
     workers: 1,
     reporter: "list",
     use: {
       baseURL: "http://localhost:3000",
       trace: "retain-on-failure",
     },
     webServer: {
       command: "MOCK_CLAUDE=true ALLOW_MEMORY_STORAGE=true npm run dev",
       url: "http://localhost:3000",
       reuseExistingServer: !process.env.CI,
       timeout: 30000,
       env: {
         MOCK_CLAUDE: "true",
         ALLOW_MEMORY_STORAGE: "true",
         ANTHROPIC_API_KEY: "mock-key-for-testing",
         AUTH_PASSWORD: "test-password",
       },
     },
   });
   ```

   Note on Windows: The `command` field with inline env vars (`MOCK_CLAUDE=true npm run dev`) may not work on Windows cmd. Use the `env` object instead which Playwright handles cross-platform. Update the command to just `npm run dev` and rely on the `env` object.

   ```typescript
   webServer: {
     command: "npm run dev",
     url: "http://localhost:3000",
     reuseExistingServer: !process.env.CI,
     timeout: 30000,
     env: {
       MOCK_CLAUDE: "true",
       ALLOW_MEMORY_STORAGE: "true",
       ANTHROPIC_API_KEY: "mock-key-for-testing",
       AUTH_PASSWORD: "test-password",
     },
   },
   ```

4. **Create `e2e/submit-workflow.spec.ts`**:

   This test covers the full critical path: login (if auth required) -> submit workflow -> observe SSE progress -> view results -> export PDF.

   ```typescript
   import { test, expect } from "@playwright/test";

   test.describe("Workflow submission and analysis flow", () => {

     test("submit workflow, view results, and export PDF", async ({ page }) => {
       // Step 1: Navigate to home page
       await page.goto("/");

       // Step 2: If auth gate appears, enter password
       // The app uses AUTH_PASSWORD env var. Check if login page appears.
       const loginInput = page.locator('input[type="password"]');
       if (await loginInput.isVisible({ timeout: 3000 }).catch(() => false)) {
         await loginInput.fill("test-password");
         await page.locator('button[type="submit"]').click();
         await page.waitForURL("/", { timeout: 5000 });
       }

       // Step 3: Enter workflow description
       // The home page has a text input/textarea for workflow description
       const descriptionInput = page.locator("textarea").first();
       await expect(descriptionInput).toBeVisible({ timeout: 10000 });
       await descriptionInput.fill(
         "Customer onboarding process: receive application, verify identity, set up account, send welcome email, schedule kickoff call."
       );

       // Step 4: Submit the workflow
       // Find and click the submit/analyze button
       const submitButton = page.locator('button:has-text("Analyze"), button:has-text("Submit"), button:has-text("Decompose")').first();
       await expect(submitButton).toBeVisible();
       await submitButton.click();

       // Step 5: Observe SSE progress indicators
       // The page shows progress messages during analysis
       // Wait for the analysis to complete -- should see a redirect to /xray/[id]
       await page.waitForURL(/\/xray\//, { timeout: 30000 });

       // Step 6: Verify results page loaded
       // The xray page should show the decomposition title, steps count, gaps count
       await expect(page.locator("h1")).toBeVisible({ timeout: 10000 });

       // Verify key result elements are present
       // Steps tag (e.g., "3 steps")
       await expect(page.locator('text=/\\d+ steps/')).toBeVisible();
       // Gaps tag (e.g., "2 gaps")
       await expect(page.locator('text=/\\d+ gaps/')).toBeVisible();

       // Step 7: Verify flow map tab is visible (default tab)
       await expect(page.locator('[role="tabpanel"]')).toBeVisible();

       // Step 8: Test PDF export
       // Click the "Download PDF" button
       const pdfButton = page.locator('button:has-text("Download PDF"), button:has-text("PDF")').first();
       await expect(pdfButton).toBeVisible();

       // Listen for download event
       const downloadPromise = page.waitForEvent("download", { timeout: 15000 });
       await pdfButton.click();
       const download = await downloadPromise;

       // Verify download happened
       expect(download.suggestedFilename()).toMatch(/\.pdf$/);
     });
   });
   ```

5. **Add E2E test script to `package.json`**:
   ```json
   "test:e2e": "playwright test"
   ```
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- no type errors in claude.ts or playwright config.
2. Run `npx vitest run` -- all existing tests plus new decompose tests pass.
3. Run `npx playwright test --reporter=list` -- E2E test passes (submits workflow, sees results, downloads PDF). This may take 30-60 seconds as it starts the dev server.

Note: If the E2E test fails on first run due to timing or selector issues, debug with `npx playwright test --headed` to see the browser, then adjust selectors/waits as needed.
  </verify>
  <done>Decompose pipeline has comprehensive unit tests using MSW network interception. MOCK_CLAUDE toggle enables zero-cost E2E testing. Playwright E2E test covers the full submit-analyze-view-export critical path without hitting the real Claude API.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` executes all unit tests (scoring, calibration, chart-data, decompose) -- all pass
2. `npx vitest run --coverage` shows coverage for src/lib/scoring.ts, src/lib/team-calibration.ts, src/lib/chart-data.ts, src/lib/decompose.ts
3. `npx playwright test` executes the E2E test -- passes without real API calls
4. MOCK_CLAUDE toggle only activates when `process.env.MOCK_CLAUDE === "true"` (no production impact)
5. No type errors: `npx tsc --noEmit` passes
</verification>

<success_criteria>
- npx vitest run passes all tests including decompose pipeline tests
- npx playwright test passes the submit-analyze-view-export E2E test
- No real Claude API calls made during any test execution
- Coverage reported for all four core lib modules (scoring, calibration, chart-data, decompose)
- MOCK_CLAUDE is a clean toggle with no side effects when disabled
</success_criteria>

<output>
After completion, create `.planning/phases/05-debt-closure-test-infrastructure/05-03-SUMMARY.md`
</output>
