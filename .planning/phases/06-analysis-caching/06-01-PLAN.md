---
phase: 06-analysis-caching
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/analysis-cache.ts
  - src/lib/types.ts
  - src/lib/validation.ts
  - src/__tests__/analysis-cache.test.ts
autonomous: true

must_haves:
  truths:
    - "computeAnalysisHash produces identical hashes for identical inputs and different hashes for different inputs"
    - "getCachedAnalysis returns null on cache miss and returns the cached entry on cache hit"
    - "setCachedAnalysis stores an entry that is retrievable by its hash"
    - "Cache entries include metadata (cachedAt, hitCount) and the full validated Decomposition"
    - "Workflow type includes optional cacheHit boolean field"
    - "DecomposeInputSchema accepts optional skipCache boolean field"
  artifacts:
    - path: "src/lib/analysis-cache.ts"
      provides: "Content hash computation, cache get/set against Vercel KV"
      exports: ["computeAnalysisHash", "getCachedAnalysis", "setCachedAnalysis", "CacheEntry"]
    - path: "src/lib/types.ts"
      provides: "cacheHit field on Workflow type"
      contains: "cacheHit"
    - path: "src/lib/validation.ts"
      provides: "skipCache field on DecomposeInputSchema"
      contains: "skipCache"
    - path: "src/__tests__/analysis-cache.test.ts"
      provides: "Unit tests for hash computation and cache operations"
      min_lines: 60
  key_links:
    - from: "src/lib/analysis-cache.ts"
      to: "src/lib/types.ts"
      via: "imports Decomposition type for CacheEntry"
      pattern: "import.*Decomposition.*from.*types"
    - from: "src/lib/analysis-cache.ts"
      to: "src/lib/decompose.ts"
      via: "imports DecomposeMetadata for CacheEntry"
      pattern: "import.*DecomposeMetadata.*from.*decompose"
    - from: "src/lib/analysis-cache.ts"
      to: "@vercel/kv or in-memory"
      via: "same getKv/getBackend pattern as db.ts"
      pattern: "kv\\.(get|set)"
---

<objective>
Build the analysis cache library with TDD: content hash computation, cache get/set operations, and the type/schema changes needed for cache support.

Purpose: This is the foundation for CACH-01 through CACH-04. The hash function determines cache identity, the get/set functions interact with Vercel KV (or in-memory for tests), and the type changes propagate cache awareness to the route and UI layers.

Output: Tested `analysis-cache.ts` module, updated `Workflow` type with `cacheHit`, updated `DecomposeInputSchema` with `skipCache`.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/types.ts
@src/lib/validation.ts
@src/lib/decompose.ts
@src/lib/db.ts
@src/lib/claude.ts
</context>

<feature>
  <name>Analysis Cache Library</name>
  <files>src/lib/analysis-cache.ts, src/__tests__/analysis-cache.test.ts, src/lib/types.ts, src/lib/validation.ts</files>
  <behavior>
    Content hash computation:
    - computeAnalysisHash({ description, stages, costContext }, promptVersion, modelId) => string (16 hex chars)
    - Normalizes description (trim, collapse whitespace, lowercase) before hashing
    - Includes stringified stages array (or empty array) in hash input
    - Includes costContext.teamSize in hash input (the field that affects analysis output)
    - Includes promptVersion and modelId so cache invalidates when prompt/model changes
    - Uses SHA-256 via Node.js crypto createHash, takes first 16 hex chars
    - Same inputs => same hash (deterministic)
    - Different description => different hash
    - Different teamSize => different hash
    - Different promptVersion => different hash
    - Whitespace-only differences in description (leading/trailing/internal) => same hash

    Cache get:
    - getCachedAnalysis(hash: string) => Promise<CacheEntry | null>
    - Returns null when key "cache:{hash}" does not exist in KV/memory
    - Returns CacheEntry when key exists, increments hitCount
    - Uses same backend detection pattern as db.ts (KV > memory with ALLOW_MEMORY_STORAGE)

    Cache set:
    - setCachedAnalysis(hash: string, entry: CacheEntry) => Promise<void>
    - Stores entry at key "cache:{hash}" with 7-day TTL (604800 seconds) when using KV
    - In-memory storage stores without TTL (acceptable for tests/dev)
    - Entry shape: { hash, decomposition, metadata, cachedAt (ISO string), hitCount: 0 }

    CacheEntry interface:
    - hash: string
    - decomposition: Decomposition
    - metadata: DecomposeMetadata
    - cachedAt: string (ISO timestamp)
    - hitCount: number

    Type changes:
    - Workflow type gets: cacheHit?: boolean
    - DecomposeInputSchema gets: skipCache: z.boolean().optional()
  </behavior>
  <implementation>
    RED phase — write tests first:
    1. Create src/__tests__/analysis-cache.test.ts
    2. Test computeAnalysisHash determinism (same input => same output)
    3. Test computeAnalysisHash differentiation (different input => different output)
    4. Test computeAnalysisHash normalization (whitespace variations => same hash)
    5. Test getCachedAnalysis returns null on miss
    6. Test setCachedAnalysis + getCachedAnalysis roundtrip
    7. Test hitCount increments on repeated gets
    8. Run tests -- all MUST fail (module does not exist yet)

    GREEN phase — implement minimally:
    1. Create src/lib/analysis-cache.ts
    2. Implement computeAnalysisHash using createHash('sha256') from crypto (same pattern as claude.ts line 116)
    3. Implement in-memory cache store (Map) as fallback, KV integration matching db.ts getKv/getBackend pattern
    4. Implement getCachedAnalysis with hitCount increment
    5. Implement setCachedAnalysis with KV set using EX option for 7-day TTL
    6. Export CacheEntry interface
    7. Run tests -- all MUST pass

    Type changes (part of GREEN, no separate test needed):
    8. Add `cacheHit?: boolean` to Workflow interface in src/lib/types.ts (after _recoveryReason line)
    9. Add `skipCache: z.boolean().optional()` to DecomposeInputSchema in src/lib/validation.ts (after parentId field)
    10. Run `npx tsc --noEmit` to verify no type errors

    REFACTOR (if needed):
    11. Clean up, ensure exports are clean
    12. Run all tests to confirm nothing broke

    IMPORTANT implementation details:
    - For KV backend: use `kv.set(key, value, { ex: 604800 })` for 7-day TTL (this is how @vercel/kv sets TTL)
    - For in-memory backend: use the globalThis pattern from db.ts for persistence across warm invocations
    - The hash must NOT include hourlyRate or hoursPerStep from costContext (these don't affect Claude's analysis output, only display-layer ROI estimates)
    - The hash MUST include teamSize because it changes the prompt sent to Claude
    - Import DecomposeMetadata from ./decompose (it's already exported)
    - Set ALLOW_MEMORY_STORAGE=true in test setup (vitest already has this pattern from Phase 5)
  </implementation>
</feature>

<verification>
1. `npx vitest run src/__tests__/analysis-cache.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no type errors across entire codebase
3. `npx vitest run` -- all existing tests still pass (no regressions)
</verification>

<success_criteria>
- computeAnalysisHash is deterministic and differentiates on description, teamSize, promptVersion, modelId
- getCachedAnalysis/setCachedAnalysis roundtrip works with in-memory backend
- CacheEntry type is exported and has correct shape
- Workflow type includes cacheHit?: boolean
- DecomposeInputSchema includes skipCache: z.boolean().optional()
- All new tests pass, all existing tests pass, TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/06-analysis-caching/06-01-SUMMARY.md`
</output>
