---
phase: 06-analysis-caching
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/decompose/route.ts
  - src/components/workflow-input.tsx
  - src/app/xray/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Submitting the same workflow description and team size twice returns cached results on the second submission without a Claude API call"
    - "Cached response is instant (no SSE streaming delay) with a progress message indicating cache hit"
    - "User can check a Force re-analysis checkbox to bypass cache and get fresh results"
    - "Results page shows a cache indicator banner when analysis was served from cache, including when it was originally created"
    - "Cache entries auto-expire after 7 days via KV TTL (set in Plan 01)"
    - "cacheHit field is set on the Workflow object saved to KV"
  artifacts:
    - path: "src/app/api/decompose/route.ts"
      provides: "Cache check between validation and Claude call, cache write after validation"
      contains: "getCachedAnalysis"
    - path: "src/components/workflow-input.tsx"
      provides: "Force re-analysis checkbox in the context section"
      contains: "skipCache"
    - path: "src/app/xray/[id]/page.tsx"
      provides: "Cache hit indicator banner on results page"
      contains: "cacheHit"
  key_links:
    - from: "src/app/api/decompose/route.ts"
      to: "src/lib/analysis-cache.ts"
      via: "imports computeAnalysisHash, getCachedAnalysis, setCachedAnalysis"
      pattern: "import.*from.*analysis-cache"
    - from: "src/app/api/decompose/route.ts"
      to: "workflow save"
      via: "sets cacheHit: true on workflow object when serving from cache"
      pattern: "cacheHit.*true"
    - from: "src/components/workflow-input.tsx"
      to: "/api/decompose"
      via: "sends skipCache in request body when checkbox is checked"
      pattern: "skipCache"
    - from: "src/app/xray/[id]/page.tsx"
      to: "workflow.cacheHit"
      via: "reads cacheHit from workflow to show indicator"
      pattern: "workflow\\.cacheHit"
---

<objective>
Integrate the analysis cache into the decompose pipeline, add the "Force re-analysis" UI control, and display cache status on the results page.

Purpose: This completes all four CACH requirements (CACH-01 through CACH-04) by wiring the cache library from Plan 01 into the actual request flow and making cache behavior visible to users.

Output: Modified decompose route with cache check/write, workflow-input with skip-cache checkbox, xray page with cache indicator.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-analysis-caching/06-01-SUMMARY.md
@src/app/api/decompose/route.ts
@src/components/workflow-input.tsx
@src/app/xray/[id]/page.tsx
@src/lib/analysis-cache.ts
@src/lib/types.ts
@src/lib/validation.ts
@src/lib/decompose.ts
@src/lib/claude.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire cache check/write into decompose route and add skipCache to input form</name>
  <files>src/app/api/decompose/route.ts, src/components/workflow-input.tsx</files>
  <action>
    DECOMPOSE ROUTE (src/app/api/decompose/route.ts):

    1. Add imports at top:
       ```
       import { computeAnalysisHash, getCachedAnalysis, setCachedAnalysis } from "@/lib/analysis-cache";
       import { getPromptVersion, getModelId } from "@/lib/claude";
       ```
       Note: getPromptVersion and getModelId are already imported indirectly via decompose.ts, but the route needs them directly for hash computation. classifyClaudeError is already imported from claude.ts -- just add getPromptVersion, getModelId to that import.

    2. Inside the SSE stream's `start(controller)` function, AFTER the `send({ type: "progress", step: "context", message: "Loading organizational context..." })` line and the enrichedDescription computation (around line 80), but BEFORE building the decomposeRequest object:

       Add cache check logic:
       ```typescript
       // ── Cache check ──
       const contentHash = computeAnalysisHash(
         {
           description: enrichedDescription,
           stages: body.stages,
           costContext: body.costContext,
         },
         getPromptVersion(),
         getModelId()
       );

       if (!body.skipCache) {
         const cached = await getCachedAnalysis(contentHash);
         if (cached) {
           send({ type: "progress", step: "cache", message: "Using cached analysis..." });

           // Assemble workflow from cached decomposition
           const workflow: Workflow = {
             id: cached.decomposition.id,
             decomposition: cached.decomposition,
             description: enrichedDescription,
             createdAt: new Date().toISOString(),
             updatedAt: new Date().toISOString(),
             ...(body.parentId ? { parentId: body.parentId, version: /* compute version same as below */ } : { version: 1 }),
             ...(body.costContext
               ? {
                   costContext: {
                     hourlyRate: body.costContext.hourlyRate,
                     hoursPerStep: body.costContext.hoursPerStep,
                     teamSize: body.costContext.teamSize,
                     teamContext: body.costContext.teamContext?.trim().slice(0, 200) || undefined,
                   },
                 }
               : {}),
             promptVersion: cached.metadata.promptVersion,
             modelUsed: cached.metadata.modelUsed,
             tokenUsage: {
               inputTokens: cached.metadata.inputTokens,
               outputTokens: cached.metadata.outputTokens,
             },
             cacheHit: true,
             cachedAt: cached.cachedAt,
           };

           // Handle version computation for cached results (same logic as existing)
           if (body.parentId) {
             try {
               const allWorkflows = await listWorkflows();
               const existingVersions = allWorkflows.filter(
                 (w) => w.parentId === body.parentId || w.id === body.parentId
               );
               const maxVersion = existingVersions.reduce(
                 (max, w) => Math.max(max, w.version || 1),
                 1
               );
               workflow.version = maxVersion + 1;
             } catch {
               workflow.version = 2;
             }
           }

           // Generate a fresh ID for this workflow instance (it's a new submission, even if cached)
           workflow.id = generateId();

           await saveWorkflow(workflow);
           send({ type: "complete", workflow });
           controller.close();
           return;
         }
       }
       ```

       IMPORTANT: Import `generateId` from `@/lib/utils` at the top of the file. The cached path needs a fresh workflow ID because each submission creates a new workflow entry (even if the analysis is the same).

    3. AFTER the existing Claude call, validation, health computation, and BEFORE the workflow save (around line 143), add cache write:
       ```typescript
       // ── Save to cache (only for non-partial results) ──
       if (!_partial) {
         try {
           await setCachedAnalysis(contentHash, {
             hash: contentHash,
             decomposition: { ...decomposition, id: decomposition.id },
             metadata: {
               promptVersion: _meta.promptVersion,
               modelUsed: _meta.modelUsed,
               inputTokens: _meta.inputTokens,
               outputTokens: _meta.outputTokens,
             },
             cachedAt: new Date().toISOString(),
             hitCount: 0,
           });
         } catch (cacheErr) {
           // Non-critical -- log and continue
           console.warn("[decompose] Cache write failed:", cacheErr);
         }
       }
       ```

    4. On the existing workflow object construction (around line 119), add `cacheHit: false` so fresh analyses are explicitly marked.

    5. Also add `cachedAt?: string` to the workflow spread -- but only when cacheHit is true (already handled in the cache hit path above).

    IMPORTANT: The `decomposition` variable from decompose result already has a generated ID. For the cache, store the decomposition as-is. When reading from cache, use generateId() for the workflow.id but keep the decomposition.id from cache (it won't conflict because workflow IDs are what KV keys use).

    Actually, re-reading the code more carefully: `decomposition` variable on line 95 is destructured from `result` with `_meta`, `_partial`, `_recoveryReason` removed. The `decomposition.id` comes from `decomposeWorkflow()` which calls `generateId()`. For cache storage, we should store the decomposition object. When retrieving from cache for a new submission, we should generate a fresh decomposition.id too since it becomes the workflow.id. Let me reconsider:

    Looking at line 120: `id: decomposition.id` -- the workflow.id IS the decomposition.id. So for cached results, generate a fresh ID and set it on BOTH:
    ```typescript
    const freshId = generateId();
    workflow.id = freshId;
    workflow.decomposition = { ...cached.decomposition, id: freshId };
    ```

    WORKFLOW-INPUT (src/components/workflow-input.tsx):

    1. Add state for skipCache:
       ```typescript
       const [skipCache, setSkipCache] = useState(false);
       ```

    2. Add skipCache to the fetch body in handleSubmit (inside the JSON.stringify call, after the costContext spread):
       ```typescript
       ...(skipCache ? { skipCache: true } : {}),
       ```

    3. Add a "Force re-analysis" checkbox in the context section. Place it AFTER the cost context help text paragraph (around line 400) and BEFORE the input mode conditional. Style it to match the existing design system:
       ```tsx
       <div style={{ marginBottom: 16 }}>
         <label
           style={{
             display: "flex",
             alignItems: "center",
             gap: 8,
             cursor: "pointer",
             fontFamily: "var(--font-mono)",
             fontSize: 11,
             color: "var(--color-muted)",
             fontWeight: 500,
           }}
         >
           <input
             type="checkbox"
             checked={skipCache}
             onChange={(e) => setSkipCache(e.target.checked)}
             style={{ accentColor: "var(--color-accent)" }}
           />
           Force re-analysis (skip cache)
         </label>
       </div>
       ```

       Place this between the closing `</div>` of the cost context section (line ~405) and the `{inputMode === "freeform" ? (` conditional (line ~407). It should always be visible, not hidden inside the cost context accordion.
  </action>
  <verify>
    1. `npx tsc --noEmit` -- no type errors
    2. `npx vitest run` -- all existing tests pass (no regressions)
    3. Review the decompose route to confirm:
       - Cache check happens after input validation, before Claude call
       - Cache write happens after successful decomposition, before workflow save
       - skipCache=true bypasses cache check
       - cacheHit is set on workflow object in both paths
  </verify>
  <done>
    - Decompose route checks cache before calling Claude and writes to cache after successful analysis
    - skipCache field is sent from the UI when checkbox is checked
    - Cached results bypass the entire Claude call and return instantly via SSE
    - Fresh analyses are cached for future use (only non-partial results)
    - cacheHit boolean is set on every workflow (true for cache hits, false for fresh)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cache indicator banner to results page and update Workflow type for cachedAt</name>
  <files>src/app/xray/[id]/page.tsx, src/lib/types.ts</files>
  <action>
    TYPES (src/lib/types.ts):

    1. Add `cachedAt?: string` to the Workflow interface (after cacheHit). This stores when the original analysis was created, displayed on the results page.
       The Workflow interface should now have:
       ```typescript
       cacheHit?: boolean;       // true when served from cache
       cachedAt?: string;        // ISO timestamp of when the cached analysis was originally created
       ```

    XRAY PAGE (src/app/xray/[id]/page.tsx):

    1. Add a cache indicator banner AFTER the team context banner and BEFORE the version timeline section (around line 671). Show it only when `workflow.cacheHit` is true:

       ```tsx
       {/* Cache hit indicator */}
       {workflow.cacheHit && (
         <div
           data-testid="cache-indicator"
           style={{
             display: "flex",
             alignItems: "center",
             gap: 8,
             padding: "8px 14px",
             background: "rgba(23, 165, 137, 0.04)",
             border: "1px solid rgba(23, 165, 137, 0.15)",
             borderRadius: "var(--radius-sm)",
             marginTop: 12,
             animation: "fadeInUp 0.4s var(--ease-spring) 0.05s both",
           }}
         >
           <span style={{
             fontFamily: "var(--font-mono)",
             fontSize: 11,
             fontWeight: 600,
             color: "var(--color-success)",
           }}>
             Cached result
           </span>
           {workflow.cachedAt && (
             <span style={{
               fontFamily: "var(--font-body)",
               fontSize: 11,
               color: "var(--color-muted)",
             }}>
               -- originally analyzed {new Date(workflow.cachedAt).toLocaleDateString(undefined, {
                 month: "short",
                 day: "numeric",
                 year: "numeric",
                 hour: "2-digit",
                 minute: "2-digit",
               })}
             </span>
           )}
           <span style={{
             fontFamily: "var(--font-body)",
             fontSize: 11,
             color: "var(--color-muted)",
             marginLeft: "auto",
           }}>
             Re-submit with &quot;Force re-analysis&quot; for fresh results
           </span>
         </div>
       )}
       ```

    2. The banner uses the same visual language as the existing partial-warning and team-context banners (same padding, border-radius, animation pattern) but with green/success color to indicate this is a positive status (fast cached response).

    3. The banner includes:
       - "Cached result" label in success green
       - Original analysis timestamp from workflow.cachedAt (formatted as "Jan 15, 2026, 02:30 PM")
       - Hint text suggesting "Force re-analysis" for fresh results
  </action>
  <verify>
    1. `npx tsc --noEmit` -- no type errors
    2. `npx vitest run` -- all existing tests pass
    3. Grep for `cacheHit` in xray page to confirm banner conditional exists
    4. Grep for `cachedAt` in types.ts to confirm field exists on Workflow
  </verify>
  <done>
    - Results page shows a green "Cached result" banner when workflow.cacheHit is true
    - Banner displays when the original analysis was created
    - Banner includes hint about "Force re-analysis" for fresh results
    - Banner does NOT appear for fresh (non-cached) analyses
    - Workflow type has both cacheHit and cachedAt optional fields
  </done>
</task>

</tasks>

<verification>
Phase 6 is complete when:
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run` passes all tests (existing + new cache tests from Plan 01)
3. The decompose route has cache check (before Claude call) and cache write (after successful analysis)
4. The workflow-input component has a "Force re-analysis" checkbox
5. The xray results page shows cache indicator when cacheHit is true
6. The Workflow type has cacheHit and cachedAt fields
7. The DecomposeInputSchema has skipCache field
8. Cache entries use 7-day TTL in KV backend
</verification>

<success_criteria>
- CACH-01: Same description + team size submitted twice returns cached results without Claude API call
- CACH-02: KV entries have 604800 second TTL (7 days) -- set in Plan 01's setCachedAnalysis
- CACH-03: "Force re-analysis" checkbox visible on input form, sends skipCache=true to bypass cache
- CACH-04: Results page shows green "Cached result" banner with original analysis timestamp
</success_criteria>

<output>
After completion, create `.planning/phases/06-analysis-caching/06-02-SUMMARY.md`
</output>
