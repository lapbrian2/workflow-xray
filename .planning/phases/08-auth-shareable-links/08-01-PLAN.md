---
phase: 08-auth-shareable-links
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - workflow-xray/middleware.ts
  - workflow-xray/src/lib/types.ts
  - workflow-xray/src/lib/validation.ts
  - workflow-xray/src/lib/db-shares.ts
autonomous: true

must_haves:
  truths:
    - "Unauthenticated requests to /api/workflows return 401"
    - "Unauthenticated requests to /api/decompose return 401"
    - "Requests to /api/auth pass through without auth check"
    - "Requests to /api/share/[token] pass through without auth check"
    - "Requests to /share/[token] page pass through without auth check"
    - "Auth cookie is validated using SHA-256 hash comparison, not just format check"
    - "ShareLink type exists with token, workflowId, createdAt, expiresAt, label, accessCount, permissions fields"
    - "Share CRUD functions exist in db-shares.ts and can create, get, list, and delete share tokens"
  artifacts:
    - path: "workflow-xray/middleware.ts"
      provides: "Auth enforcement middleware"
      contains: "crypto.subtle"
    - path: "workflow-xray/src/lib/db-shares.ts"
      provides: "Share link KV CRUD operations"
      exports: ["createShareLink", "getShareLink", "listShareLinks", "deleteShareLink", "deleteShareLinksForWorkflow"]
    - path: "workflow-xray/src/lib/types.ts"
      provides: "ShareLink type definition"
      contains: "ShareLink"
    - path: "workflow-xray/src/lib/validation.ts"
      provides: "Share link Zod schemas"
      contains: "CreateShareLinkSchema"
  key_links:
    - from: "workflow-xray/middleware.ts"
      to: "workflow-xray/src/lib/auth.ts"
      via: "Uses same AUTH_COOKIE_NAME and hash logic"
      pattern: "xray_auth"
    - from: "workflow-xray/src/lib/db-shares.ts"
      to: "@vercel/kv"
      via: "KV operations for share:token and workflow:id:shares keys"
      pattern: "share:"
---

<objective>
Create the auth middleware that enforces authentication boundaries across all routes, and build the share link data layer (types, validation schemas, KV operations).

Purpose: AUTH-01 and AUTH-02 require server-side auth enforcement -- currently NO API route checks the auth cookie. This is the security foundation that must exist before any sharing feature. The share data layer (types, schemas, db functions) is co-located here because it has no dependencies and is needed by both Plan 02 (management APIs) and Plan 03 (public share view).

Output: middleware.ts enforcing auth on all routes except public ones; ShareLink type; Zod schemas for share operations; db-shares.ts with full share CRUD.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@workflow-xray/src/lib/auth.ts
@workflow-xray/src/lib/types.ts
@workflow-xray/src/lib/validation.ts
@workflow-xray/src/lib/db.ts
@workflow-xray/src/lib/api-errors.ts
@workflow-xray/src/app/api/workflows/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Next.js middleware with Web Crypto API auth validation</name>
  <files>workflow-xray/middleware.ts</files>
  <action>
Create `middleware.ts` at the project root (`workflow-xray/middleware.ts`) -- this is where Next.js expects it.

The middleware must:

1. Define a `PUBLIC_PATHS` set of route prefixes that skip auth:
   - `/api/auth` (login/logout)
   - `/api/share/` (public share token lookup -- note the trailing slash to match dynamic segments)
   - `/share/` (public share view page)
   - `/login` (login page)
   - `/favicon.ico`
   - `/_next/` (Next.js internals)

2. For all other routes, check for the `xray_auth` cookie (import `AUTH_COOKIE_NAME` from `@/lib/auth`).

3. If no cookie present, return a 401 JSON response for API routes (`/api/*`) or redirect to `/login` for page routes.

4. If cookie IS present, validate it using Web Crypto API (NOT Node.js crypto -- middleware runs on Edge Runtime):
   - Get `AUTH_PASSWORD` and `AUTH_PASSWORD_SALT` from `process.env`
   - If `AUTH_PASSWORD` is not set, skip auth (auth disabled)
   - Encode `${salt}:${password}` as UTF-8 using `TextEncoder`
   - Hash with `crypto.subtle.digest('SHA-256', encoded)`
   - Convert to hex string
   - Compare with the cookie value using constant-time comparison
   - IMPORTANT: Cannot use Node.js `crypto.timingSafeEqual` in Edge Runtime. Implement a simple constant-time hex comparison: iterate all characters, accumulate XOR differences, return true only if all match.

5. If hash matches, call `NextResponse.next()`. If not, return 401 or redirect to `/login`.

6. Export a `config` object with `matcher` that excludes static files:
   ```typescript
   export const config = {
     matcher: [
       '/((?!_next/static|_next/image|favicon.ico).*)',
     ],
   };
   ```

IMPORTANT: Do NOT import from `@/lib/auth` for the hash function itself -- middleware runs on Edge Runtime and cannot use Node.js `crypto` module. Reimplement the SHA-256 hash using Web Crypto API. DO import `AUTH_COOKIE_NAME` as a string constant (that works fine).

The constant-time comparison function should look like:
```typescript
function constantTimeEqual(a: string, b: string): boolean {
  if (a.length !== b.length) return false;
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return result === 0;
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors in middleware.ts)
2. Manually verify the file exists at `workflow-xray/middleware.ts` (NOT in src/)
3. Verify the file imports `NextResponse` from `next/server`
4. Verify `crypto.subtle.digest` is used (not Node.js crypto)
5. Verify PUBLIC_PATHS includes `/api/auth`, `/api/share/`, `/share/`, `/login`
  </verify>
  <done>
middleware.ts exists at project root. It validates auth cookies using Web Crypto SHA-256 on all non-public routes. Public routes (/api/auth, /api/share/*, /share/*, /login) pass through without auth check. Invalid or missing cookies get 401 (API) or redirect to /login (pages).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ShareLink type, Zod schemas, and db-shares.ts CRUD</name>
  <files>
    workflow-xray/src/lib/types.ts
    workflow-xray/src/lib/validation.ts
    workflow-xray/src/lib/db-shares.ts
  </files>
  <action>
**In `src/lib/types.ts`** -- Add at the end of the file (after RemediationPlan types):

```typescript
// --- Share Link Types ---

export interface ShareLink {
  token: string;              // crypto.randomUUID() -- URL-safe unique token
  workflowId: string;         // ID of the shared workflow
  label?: string;             // Optional user-provided label (e.g. "For client review")
  createdAt: string;          // ISO timestamp
  expiresAt?: string;         // ISO timestamp -- null means no expiry
  accessCount: number;        // How many times the share link has been accessed
  lastAccessedAt?: string;    // ISO timestamp of last access
  permissions: "readonly";    // Only readonly for now -- future-proofing the field
}
```

**In `src/lib/validation.ts`** -- Add at the end of the file:

```typescript
// --- /api/shares (POST -- create share link) ---

export const CreateShareLinkSchema = z.object({
  workflowId: z.string().min(1, { error: "Workflow ID is required." }),
  label: z.string().max(200).optional(),
  expiresInDays: z.number().int().min(1).max(365).optional(),
});
export type CreateShareLinkInput = z.infer<typeof CreateShareLinkSchema>;

// --- /api/shares (DELETE -- revoke share link) ---

export const DeleteShareLinkSchema = z.object({
  token: z.string().min(1, { error: "Share token is required." }),
});
export type DeleteShareLinkInput = z.infer<typeof DeleteShareLinkSchema>;
```

**Create `src/lib/db-shares.ts`** -- New file with KV share operations:

```typescript
import type { ShareLink } from "./types";
```

This module follows the same KV access pattern as `db.ts` (dynamically import `@vercel/kv`, check env vars).

Functions to implement:

1. `createShareLink(workflowId: string, label?: string, expiresInDays?: number): Promise<ShareLink>`
   - Generate token with `crypto.randomUUID()`
   - Build ShareLink object with createdAt = now, accessCount = 0, permissions = "readonly"
   - If expiresInDays provided, set expiresAt = now + days
   - Store in KV: `kv.set("share:{token}", JSON.stringify(shareLink))` -- if expiresInDays is set, pass `{ ex: expiresInDays * 86400 }` for TTL
   - Add token to secondary index: `kv.sadd("workflow:{workflowId}:shares", token)`
   - Return the ShareLink

2. `getShareLink(token: string): Promise<ShareLink | null>`
   - `kv.get("share:{token}")` -- parse JSON, return null if not found
   - If found, increment accessCount and update lastAccessedAt:
     - Update the object, `kv.set("share:{token}", JSON.stringify(updated))` preserving existing TTL by reading the TTL with `kv.ttl("share:{token}")` and passing it back via `{ ex: remainingTtl }` (only if ttl > 0)
   - Return the ShareLink

3. `listShareLinks(workflowId: string): Promise<ShareLink[]>`
   - `kv.smembers("workflow:{workflowId}:shares")` to get all tokens
   - Batch fetch each token's ShareLink via `getShareLink` (but WITHOUT incrementing accessCount -- create a private `_getShareLinkRaw` for reads without side effects)
   - Filter out null results (expired/deleted tokens)
   - Clean up stale tokens from the set (if a token returned null, `kv.srem` it from the set)
   - Sort by createdAt descending

4. `deleteShareLink(token: string): Promise<boolean>`
   - Get the share link first to know the workflowId
   - `kv.del("share:{token}")`
   - `kv.srem("workflow:{workflowId}:shares", token)`
   - Return true

5. `deleteShareLinksForWorkflow(workflowId: string): Promise<number>`
   - `kv.smembers("workflow:{workflowId}:shares")` to get all tokens
   - Delete each: `kv.del("share:{token}")` for each token
   - Delete the index: `kv.del("workflow:{workflowId}:shares")`
   - Return count of deleted tokens

Use the same `getKv()` / `getBackend()` pattern from db.ts. For memory fallback, use a simple Map<string, ShareLink> and a Map<string, Set<string>> for the secondary index. Include the same ALLOW_MEMORY_STORAGE guard as db.ts.

IMPORTANT: The `getShareLink` function is called from the PUBLIC share route, so it must work without auth. The access count update is best-effort (do not throw if it fails).
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Grep for `ShareLink` in types.ts -- type exists with all required fields
3. Grep for `CreateShareLinkSchema` in validation.ts -- schema exists
4. Grep for `createShareLink` in db-shares.ts -- all 5 functions exported
5. Verify db-shares.ts has memory fallback for ALLOW_MEMORY_STORAGE
  </verify>
  <done>
ShareLink type added to types.ts. CreateShareLinkSchema and DeleteShareLinkSchema added to validation.ts. db-shares.ts created with createShareLink, getShareLink, listShareLinks, deleteShareLink, deleteShareLinksForWorkflow -- all with KV primary storage and memory fallback.
  </done>
</task>

</tasks>

<verification>
1. `cd workflow-xray && npx tsc --noEmit` -- zero type errors
2. middleware.ts exists at project root (not src/)
3. Middleware uses `crypto.subtle.digest` (Edge Runtime compatible)
4. All 5 db-shares.ts functions are exported and typed
5. ShareLink type has: token, workflowId, label?, createdAt, expiresAt?, accessCount, lastAccessedAt?, permissions
6. No existing tests broken: `npm test` (if test suite exists)
</verification>

<success_criteria>
- Unauthenticated requests to protected API routes would return 401 (verified by middleware logic inspection -- full integration test requires running dev server)
- Public routes (/api/auth, /api/share/*, /share/*, /login) skip auth
- Auth cookie validated via SHA-256 hash using Web Crypto API, not format-only check
- ShareLink data model complete with types, schemas, and CRUD operations
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-auth-shareable-links/08-01-SUMMARY.md`
</output>
