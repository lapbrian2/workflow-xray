---
phase: 01-infrastructure-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db.ts
  - src/lib/auth.ts
  - proxy.ts
  - middleware.ts
autonomous: true

must_haves:
  truths:
    - "Missing KV/Blob env vars cause a hard error instead of silent in-memory fallback"
    - "ALLOW_MEMORY_STORAGE=true explicitly enables in-memory storage for local dev"
    - "workflow:ids uses Redis Set operations (SADD/SMEMBERS/SREM) instead of GET-then-SET array"
    - "A spoofed auth cookie (valid 64-char hex but wrong hash) is rejected and user is redirected to login"
    - "proxy.ts performs real SHA-256 hash validation using node:crypto"
  artifacts:
    - path: "src/lib/db.ts"
      provides: "Fail-hard storage initialization + atomic Set-based ID tracking"
      contains: "ALLOW_MEMORY_STORAGE"
    - path: "proxy.ts"
      provides: "Node.js runtime request interceptor with real auth hash validation"
      contains: "safeCompare"
    - path: "src/lib/auth.ts"
      provides: "Auth utilities including getExpectedToken and safeCompare"
      exports: ["getExpectedToken", "safeCompare", "AUTH_COOKIE_NAME"]
  key_links:
    - from: "proxy.ts"
      to: "src/lib/auth.ts"
      via: "import getExpectedToken, safeCompare"
      pattern: "import.*getExpectedToken.*safeCompare.*from.*auth"
    - from: "src/lib/db.ts"
      to: "@vercel/kv"
      via: "kv.sadd, kv.smembers, kv.srem calls"
      pattern: "kv\\.(sadd|smembers|srem)"
---

<objective>
Harden storage persistence and authentication security -- the two independent infrastructure fixes that eliminate silent data loss (INFR-01) and auth cookie spoofing (INFR-02).

Purpose: These are the highest-severity issues: data silently disappearing and anyone with a 64-char hex string bypassing auth. Both must be fixed before any other route-level work.
Output: A db.ts that fails hard without storage config + uses atomic Redis Sets for ID tracking, and a proxy.ts that validates auth cookies against the real password hash.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-security/01-RESEARCH.md

@src/lib/db.ts
@src/lib/auth.ts
@middleware.ts
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden db.ts -- fail-hard storage + atomic KV Set operations</name>
  <files>src/lib/db.ts</files>
  <action>
Modify `src/lib/db.ts` to address two issues:

**1. Fail-hard storage initialization (INFR-01):**
Change `getBackend()` so that when neither KV nor Blob env vars are configured, it checks for `process.env.ALLOW_MEMORY_STORAGE === "true"`. If that flag is NOT set, throw an Error with a clear message listing the required env vars. If the flag IS set, log a console.warn and return "memory". This prevents silent data loss in production while allowing explicit local dev usage.

Keep the in-memory Map and `globalStore` pattern for when memory IS explicitly allowed, but the Map should NEVER be used without the explicit opt-in.

**2. Atomic KV ID tracking with Redis Sets (race condition fix):**
Replace all `workflow:ids` array-based operations with Redis Set commands:
- In `saveWorkflow`: Replace the GET-then-SET pattern (lines 52-66) with `await kv.sadd("workflow:ids", workflow.id)`. SADD is atomic and idempotent -- no need to check if ID already exists.
- In `listWorkflows`: Replace `kv.get("workflow:ids")` + JSON.parse logic (lines 130-139) with `const ids: string[] = await kv.smembers("workflow:ids")`. SMEMBERS returns all set members as an array.
- In `deleteWorkflow`: Replace the GET-filter-SET pattern (lines 192-204) with `await kv.srem("workflow:ids", id)`. SREM is atomic.

**3. One-time migration from array to set:**
Add a `migrateIdsToSet` helper function that:
- Reads the old `workflow:ids` key with `kv.get()`
- If the value is an array or JSON string array, DEL the key, then SADD all IDs
- If `kv.get()` returns null (already a Set or empty), skip migration
- Wrap SADD in try/catch to handle WRONGTYPE errors gracefully (the key may already be a Set)
- Log the migration with `console.log("[db] Migrated N workflow IDs from array to Redis Set")`

Call `migrateIdsToSet` at the start of `listWorkflows` (the first read operation where the format matters). Use a module-level `let migrated = false` flag so it only runs once per cold start.

Important: The `@vercel/kv` 3.0.0 package (via `@upstash/redis`) exports `sadd`, `smembers`, and `srem` methods on the kv object. These are confirmed available. The kv object from `import { kv } from "@vercel/kv"` has these methods directly.
  </action>
  <verify>
1. Read the modified db.ts and confirm:
   - `getBackend()` throws when no env vars and no ALLOW_MEMORY_STORAGE
   - All `kv.get("workflow:ids")` / `kv.set("workflow:ids", ...)` patterns are replaced with `kv.sadd` / `kv.smembers` / `kv.srem`
   - `migrateIdsToSet` function exists and is called from `listWorkflows`
2. Run `npx tsc --noEmit` to verify no TypeScript errors
  </verify>
  <done>
- getBackend() throws descriptive error when KV/Blob/ALLOW_MEMORY_STORAGE are all missing
- getBackend() returns "memory" with console.warn when ALLOW_MEMORY_STORAGE=true
- saveWorkflow uses kv.sadd("workflow:ids", workflow.id)
- listWorkflows uses kv.smembers("workflow:ids")
- deleteWorkflow uses kv.srem("workflow:ids", id)
- migrateIdsToSet runs once on first listWorkflows call
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate middleware.ts to proxy.ts with real auth hash validation</name>
  <files>proxy.ts, middleware.ts, src/lib/auth.ts</files>
  <action>
**1. Create `proxy.ts` in the project root** (same level as `middleware.ts`):

This is the Next.js 16 replacement for middleware.ts. It runs on the Node.js runtime (NOT Edge), which means it can import `node:crypto` and use the full `auth.ts` module.

The proxy function should:
- Export a named function `proxy(request: NextRequest)` (NOT `middleware`)
- Import `getExpectedToken`, `safeCompare`, `AUTH_COOKIE_NAME` from `@/lib/auth`
- Allow through without auth: `/login`, `/api/auth*`, `/_next*`, static file extensions (.ico, .png, .svg, .jpg, .css, .js)
- If `AUTH_PASSWORD` is not set, return `NextResponse.next()` (auth disabled)
- If auth cookie is missing, redirect to `/login?from={pathname}`
- **CRITICAL: Validate the cookie hash** -- call `getExpectedToken()` to get the expected SHA-256 hash, then `safeCompare(cookieValue, expectedToken)`. If validation fails, redirect to `/login?from={pathname}` AND delete the invalid cookie.
- If cookie is valid, return `NextResponse.next()`
- Export `config` with the same matcher as current middleware.ts: `"/((?!_next/static|_next/image|favicon.ico).*)"`

**2. Delete `middleware.ts`:**
Remove the file entirely. Next.js 16 uses `proxy.ts` as the convention. Having both could cause conflicts.

**3. Verify `src/lib/auth.ts` exports:**
The auth.ts file already exports `getExpectedToken`, `safeCompare`, `AUTH_COOKIE_NAME`, `hashPassword`, `isAuthEnabled`, and `AUTH_COOKIE_MAX_AGE`. No changes needed to auth.ts itself -- it already has everything proxy.ts needs. Just confirm the imports work.

**4. Check `next.config.ts`:**
If `next.config.ts` has any `skipMiddlewareUrlNormalize` setting, rename it to `skipProxyUrlNormalize`. Currently the config does NOT have this setting, so no change should be needed. Just verify.

**Important notes:**
- proxy.ts uses Node.js runtime by default in Next.js 16 -- do NOT add `export const runtime = "edge"` or similar
- The function name MUST be `proxy` not `middleware`
- Import paths use `@/lib/auth` (same as API routes)
  </action>
  <verify>
1. Confirm `proxy.ts` exists at project root with `proxy` function export
2. Confirm `middleware.ts` has been deleted
3. Grep proxy.ts for `safeCompare` and `getExpectedToken` to verify real hash validation
4. Run `npx tsc --noEmit` to verify no TypeScript errors
5. Confirm `next.config.ts` has no deprecated middleware config flags
  </verify>
  <done>
- proxy.ts exists at project root, exports `proxy` function and `config`
- proxy.ts imports and uses `getExpectedToken()` + `safeCompare()` for real hash validation
- proxy.ts redirects to /login and deletes cookie when hash validation fails
- middleware.ts is deleted
- No TypeScript compilation errors
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- db.ts: `getBackend()` without any env vars throws (grep for "throw new Error" in getBackend)
- db.ts: No remaining `kv.get("workflow:ids")` or `kv.set("workflow:ids"` patterns (grep confirms replacement with sadd/smembers/srem)
- proxy.ts: Contains `safeCompare` call (not just regex format check)
- middleware.ts: Does not exist
</verification>

<success_criteria>
1. Storage fails hard when unconfigured (INFR-01): `getBackend()` throws without env vars
2. Memory storage requires explicit opt-in: `ALLOW_MEMORY_STORAGE=true`
3. KV race condition eliminated: workflow:ids uses atomic Redis Set operations
4. Auth spoofing blocked (INFR-02): proxy.ts validates cookie hash against real expected value
5. TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-security/01-01-SUMMARY.md`
</output>
