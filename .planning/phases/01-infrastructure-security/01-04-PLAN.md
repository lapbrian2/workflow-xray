---
phase: 01-infrastructure-security
plan: 04
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/app/api/remediation-notion-sync/route.ts
  - src/app/api/extract-workflows/route.ts
  - src/app/api/extract-from-screenshot/route.ts
  - src/app/api/scrape-url/route.ts
  - src/app/api/crawl-site/route.ts
  - src/app/api/parse-file/route.ts
  - src/components/freeform-input.tsx
  - src/components/workflow-input.tsx
  - src/components/workflow-library.tsx
  - src/app/login/page.tsx
  - src/app/xray/[id]/page.tsx
  - src/app/xray/[id]/remediation/page.tsx
autonomous: true

must_haves:
  truths:
    - "All 6 remaining routes return errors in { error: { code, message, details? } } shape"
    - "All 6 remaining routes validate input with Zod schemas before processing"
    - "crawl-site SSE pre-stream errors use structured JSON shape; error events within the stream include code and message fields"
    - "parse-file uses withApiHandler with bodyType none and validates extracted FormData fields with Zod"
    - "Frontend components read error.message (not error as string) from API error responses"
    - "No route in this batch leaks err.message to the client"
  artifacts:
    - path: "src/app/api/crawl-site/route.ts"
      provides: "SSE crawl with structured pre-stream errors and structured error events"
      exports: ["POST"]
    - path: "src/app/api/parse-file/route.ts"
      provides: "File parsing with FormData + Zod validation + structured errors"
      exports: ["POST"]
    - path: "src/components/freeform-input.tsx"
      provides: "Main input component with updated error parsing for new API shape"
      contains: "error.message"
  key_links:
    - from: "src/components/freeform-input.tsx"
      to: "API routes"
      via: "fetch error parsing reads .error.message instead of .error"
      pattern: "\\.error\\.message"
    - from: "src/app/api/crawl-site/route.ts"
      to: "src/lib/api-errors.ts"
      via: "import for pre-stream error responses"
      pattern: "import.*from.*api-errors"
    - from: "src/app/api/parse-file/route.ts"
      to: "src/lib/api-handler.ts"
      via: "import withApiHandler with bodyType none"
      pattern: "withApiHandler.*bodyType.*none"
---

<objective>
Migrate the 6 remaining API routes (including special cases: SSE streaming and FormData) and update all frontend error parsing to handle the new structured error shape (INFR-03 + INFR-04 completion).

Purpose: Completes the migration of all 13 routes to structured errors + Zod validation. Also updates the frontend so error messages display correctly with the new { error: { code, message } } shape instead of the old { error: "string" } shape.
Output: All 13 API routes return consistent structured errors. All frontend components parse the new error shape. Phase 1 requirements fully satisfied.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-security/01-RESEARCH.md
@.planning/phases/01-infrastructure-security/01-02-SUMMARY.md

@src/lib/api-handler.ts
@src/lib/api-errors.ts
@src/lib/validation.ts
@src/app/api/remediation-notion-sync/route.ts
@src/app/api/extract-workflows/route.ts
@src/app/api/extract-from-screenshot/route.ts
@src/app/api/scrape-url/route.ts
@src/app/api/crawl-site/route.ts
@src/app/api/parse-file/route.ts
@src/components/freeform-input.tsx
@src/components/workflow-input.tsx
@src/components/workflow-library.tsx
@src/app/login/page.tsx
@src/app/xray/[id]/page.tsx
@src/app/xray/[id]/remediation/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate 6 remaining routes including crawl-site SSE and parse-file FormData</name>
  <files>src/app/api/remediation-notion-sync/route.ts, src/app/api/extract-workflows/route.ts, src/app/api/extract-from-screenshot/route.ts, src/app/api/scrape-url/route.ts, src/app/api/crawl-site/route.ts, src/app/api/parse-file/route.ts</files>
  <action>
Migrate these 6 routes using the same pattern as Plan 03, with special handling for crawl-site and parse-file.

**Standard routes (same pattern as Plan 03):**

**remediation-notion-sync/route.ts (POST):**
- Wrap with `withApiHandler(handler, { schema: RemediationNotionSyncSchema })`
- Replace manual validation and error responses
- Keep rate limiting

**extract-workflows/route.ts (POST):**
- Wrap with `withApiHandler(handler, { schema: ExtractWorkflowsSchema })`
- CRITICAL: This route currently LEAKS err.message (line ~120: `error: err instanceof Error ? err.message : "..."`). Remove this. Throw `AppError("AI_ERROR", "Extraction failed. Please try again.", 502)` instead.
- Keep rate limiting

**extract-from-screenshot/route.ts (POST):**
- Wrap with `withApiHandler(handler, { schema: ExtractFromScreenshotSchema })`
- CRITICAL: This route currently LEAKS err.message (line ~113). Remove this. Throw `AppError("AI_ERROR", "Screenshot extraction failed.", 502)` instead.
- Keep rate limiting

**scrape-url/route.ts (POST):**
- Wrap with `withApiHandler(handler, { schema: ScrapeUrlSchema })`
- This route has good SSRF protection -- preserve it (URL validation, domain checks)
- Keep rate limiting

**Special case routes:**

**crawl-site/route.ts (POST) -- SSE streaming:**
- DO NOT wrap the entire route with `withApiHandler`. The response is a `text/event-stream`, not JSON.
- Instead, use a hybrid approach:
  1. At the top of the handler, manually validate input using the CrawlSiteSchema: `const result = CrawlSiteSchema.safeParse(body)`. If validation fails, return a structured JSON error response using `errorResponse()` from api-errors.ts (this happens BEFORE the stream starts).
  2. Rate limiting: if blocked, return structured JSON error (before stream).
  3. Missing API key: return structured JSON error (before stream).
  4. Once the stream starts, error events within the SSE should include structured data: `data: ${JSON.stringify({ type: "error", error: { code: "AI_ERROR", message: "..." } })}` instead of just `data: ${JSON.stringify({ type: "error", error: "..." })}`.
  5. CRITICAL: Lines ~417 and ~444 currently leak err.message. Replace with sanitized messages.
- Import `AppError` and error helpers for the pre-stream errors. Import the Zod schema for validation.

**parse-file/route.ts (POST) -- FormData:**
- Wrap with `withApiHandler(handler, { bodyType: "none" })` -- the wrapper should NOT try to parse JSON
- Inside the handler, extract FormData manually: `const formData = await request.formData()`
- After extracting fields from FormData, validate them with `ParseFileMetaSchema.safeParse({ fileName, fileType, content })` or similar
- If validation fails, throw `AppError("VALIDATION_ERROR", "Invalid file upload.", 400, details)`
- CRITICAL: Line ~155 currently leaks err.message. Replace with sanitized message.
- Keep rate limiting

**For all routes:** Never leak err.message. Log with console.error, throw AppError with sanitized message.
  </action>
  <verify>
1. Grep all 6 route files for `withApiHandler` OR manual schema validation -- each should have one
2. Grep for `err.message` or `error.message` in response bodies (NOT console.error) -- should find ZERO
3. Grep crawl-site for structured error events in SSE: should find `code` and `message` in error event data
4. Grep parse-file for `bodyType.*none` -- should find it
5. Run `npx tsc --noEmit` to verify no TypeScript errors
  </verify>
  <done>
- All 6 routes use structured error responses
- crawl-site: pre-stream errors are structured JSON, in-stream error events include code+message
- parse-file: uses bodyType none, validates FormData fields with Zod after extraction
- extract-workflows, extract-from-screenshot, parse-file: err.message leaks eliminated
- Rate limiting preserved on all routes that had it
  </done>
</task>

<task type="auto">
  <name>Task 2: Update frontend error parsing for new API error shape</name>
  <files>src/components/freeform-input.tsx, src/components/workflow-input.tsx, src/components/workflow-library.tsx, src/app/login/page.tsx, src/app/xray/[id]/page.tsx, src/app/xray/[id]/remediation/page.tsx</files>
  <action>
The API error shape is changing from `{ error: "string" }` to `{ error: { code: "string", message: "string", details?: unknown } }`. All frontend code that reads `.error` from API responses needs updating.

**Search and replace pattern:**
The frontend currently does patterns like:
- `err.error || "fallback message"` -- needs to become `err.error?.message || "fallback message"`
- `data.error` used as a string -- needs to become `data.error?.message`
- `throw new Error(err.error || "...")` -- needs to become `throw new Error(err.error?.message || "...")`

**File-by-file updates:**

**freeform-input.tsx** (most references):
Search for all instances of `err.error` or `data.error` used as a string value. Update each to read `.error.message` instead. Instances found during research:
- Line ~595: `errMsg = err.error || errMsg` -> `errMsg = err.error?.message || errMsg`
- Line ~746: `errMsg = err.error || errMsg` -> `errMsg = err.error?.message || errMsg`
- Line ~822: `event.error as string` -- this is SSE event data from crawl-site. After the crawl-site migration, error events will have `{ error: { code, message } }`. Update to read `event.error?.message || event.error` (handle both shapes during transition).
- Line ~927: `error: event.error as string` -- same SSE pattern, update similarly
- Line ~944: `event.error as string` -- same pattern
- Line ~1016: `errMsg = err.error || errMsg` -> `errMsg = err.error?.message || errMsg`
- Line ~1149: `errMsg = err.error || errMsg` -> `errMsg = err.error?.message || errMsg`
- Line ~1196: `throw new Error(err.error || "Extraction failed")` -> `throw new Error(err.error?.message || "Extraction failed")`
- Line ~1290: `errMsg = err.error || errMsg` -> `errMsg = err.error?.message || errMsg`
- Line ~1491: `throw new Error(err.error || "Screenshot extraction failed")` -> `throw new Error(err.error?.message || "Screenshot extraction failed")`

**workflow-input.tsx:**
- Line ~71: `throw new Error(err.error || "Decomposition failed")` -> `throw new Error(err.error?.message || "Decomposition failed")`

**workflow-library.tsx:**
- Line ~136: `err.error || "failed"` -> `err.error?.message || "failed"`

**login/page.tsx:**
- Line ~42: `setError(data.error || "Authentication failed.")` -> `setError(data.error?.message || "Authentication failed.")`

**xray/[id]/page.tsx:**
- Line ~88: `throw new Error(err.error || "Sync failed")` -> `throw new Error(err.error?.message || "Sync failed")`

**xray/[id]/remediation/page.tsx:**
- Line ~167: `throw new Error(err.error || "Failed to generate plan")` -> `throw new Error(err.error?.message || "Failed to generate plan")`
- Line ~218: `throw new Error(err.error || "Sync failed")` -> `throw new Error(err.error?.message || "Sync failed")`

**IMPORTANT:** Use optional chaining (`err.error?.message`) to handle edge cases where the response might not match the expected shape. This provides graceful degradation.

**Also handle the truthiness check:** Some frontend code checks `if (data.error)` to detect errors. Since `data.error` is now an object (truthy), this pattern STILL WORKS. No changes needed for error detection -- only for error message EXTRACTION.
  </action>
  <verify>
1. Grep all 6 frontend files for `\.error\s*\|\|` or `\.error\s*\?\?` (old string pattern) -- should find ZERO
2. Grep all 6 frontend files for `\.error\.message` or `\.error\?\.message` -- should find all the updated references
3. Run `npx tsc --noEmit` to verify no TypeScript errors
4. Verify that error detection patterns (`if (data.error)`) are preserved and still work with object shape
  </verify>
  <done>
- All frontend error parsing reads .error.message (or .error?.message) instead of .error as string
- Optional chaining used everywhere for graceful degradation
- Error detection (truthiness checks) still works since object is truthy
- SSE event error parsing handles new shape
- No TypeScript errors
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- ALL 13 API routes now use structured error responses (grep all route.ts files for withApiHandler or manual schema validation)
- ZERO instances of `{ error: "string" }` error response pattern in any route file
- ZERO instances of err.message leaked in API responses (only in console.error)
- ALL frontend components read .error.message (not .error as string)
- `npm run build` succeeds (full Next.js build validates everything)
</verification>

<success_criteria>
1. All 13 API routes return errors as { error: { code, message, details? } }
2. All 13 routes validate input with Zod before processing
3. No route leaks internal error messages (err.message) to clients
4. Frontend correctly displays error messages from new API shape
5. crawl-site SSE handles errors correctly (pre-stream JSON + in-stream structured events)
6. parse-file handles FormData correctly (bodyType none + post-extraction Zod validation)
7. Full TypeScript compilation and Next.js build succeed
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-security/01-04-SUMMARY.md`
</output>
