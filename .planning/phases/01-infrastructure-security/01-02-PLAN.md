---
phase: 01-infrastructure-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api-errors.ts
  - src/lib/api-handler.ts
  - src/lib/validation.ts
autonomous: true

must_haves:
  truths:
    - "An AppError thrown in any handler produces a structured JSON response with code, message, and optional details"
    - "Unknown errors produce a generic INTERNAL_ERROR response without leaking err.message"
    - "Zod validation failures produce a VALIDATION_ERROR response with field-level issue details"
    - "withApiHandler automatically parses and validates JSON body for POST/PUT/PATCH requests"
    - "withApiHandler supports skipping body parsing for FormData routes (parse-file)"
    - "Zod schemas exist for all 13 API route inputs with appropriate constraints"
  artifacts:
    - path: "src/lib/api-errors.ts"
      provides: "AppError class and structured error response helpers"
      exports: ["AppError", "errorResponse", "badRequest", "unauthorized", "notFound", "rateLimited", "serviceUnavailable", "internalError"]
    - path: "src/lib/api-handler.ts"
      provides: "withApiHandler HOF that wraps route handlers with error handling and validation"
      exports: ["withApiHandler"]
    - path: "src/lib/validation.ts"
      provides: "Zod schemas for all API route inputs"
      exports: ["AuthLoginSchema", "DecomposeInputSchema", "WorkflowSaveSchema", "WorkflowDeleteSchema", "CompareSchema", "RemediationInputSchema", "NotionImportSchema", "NotionSyncSchema", "RemediationNotionSyncSchema", "ExtractWorkflowsSchema", "ExtractFromScreenshotSchema", "ScrapeUrlSchema", "CrawlSiteSchema", "ParseFileMetaSchema"]
  key_links:
    - from: "src/lib/api-handler.ts"
      to: "src/lib/api-errors.ts"
      via: "import AppError, error response helpers"
      pattern: "import.*AppError.*from.*api-errors"
    - from: "src/lib/api-handler.ts"
      to: "zod"
      via: "z.ZodType for schema parameter, z.ZodError for catch"
      pattern: "z\\.Zod(Type|Error)"
---

<objective>
Create the shared error handling infrastructure and Zod validation schemas that all 13 API routes will use -- the foundation for INFR-03 (consistent errors) and INFR-04 (input validation).

Purpose: Every route currently has its own try/catch with different error shapes and inline typeof validation. This plan creates the reusable primitives (AppError, withApiHandler, schemas) that Plans 03 and 04 will apply to each route.
Output: Three new library files that provide consistent error responses, automatic body parsing/validation, and Zod schemas for every API input.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-security/01-RESEARCH.md

@src/lib/rate-limit.ts
@src/lib/types.ts
@src/app/api/decompose/route.ts
@src/app/api/auth/route.ts
@src/app/api/workflows/route.ts
@src/app/api/compare/route.ts
@src/app/api/remediation/route.ts
@src/app/api/notion-import/route.ts
@src/app/api/notion-sync/route.ts
@src/app/api/remediation-notion-sync/route.ts
@src/app/api/extract-workflows/route.ts
@src/app/api/extract-from-screenshot/route.ts
@src/app/api/scrape-url/route.ts
@src/app/api/crawl-site/route.ts
@src/app/api/parse-file/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppError class and structured error response helpers</name>
  <files>src/lib/api-errors.ts</files>
  <action>
Create `src/lib/api-errors.ts` with:

**1. AppError class:**
```typescript
export class AppError extends Error {
  constructor(
    public code: string,
    message: string,
    public statusCode: number = 400,
    public details?: unknown
  ) {
    super(message);
    this.name = "AppError";
  }
}
```

**2. Error response type:**
```typescript
export interface ApiErrorResponse {
  error: {
    code: string;
    message: string;
    details?: unknown;
  };
}
```

**3. `errorResponse` function:**
Takes `code: string`, `message: string`, `status: number`, optional `details: unknown`. Returns `NextResponse.json({ error: { code, message, ...details } }, { status })`. Only include `details` key if details is not undefined.

**4. Convenience helpers** (all return NextResponse):
- `badRequest(message: string, details?: unknown)` -- 400, code "VALIDATION_ERROR"
- `unauthorized(message = "Authentication required")` -- 401, code "UNAUTHORIZED"
- `notFound(message = "Resource not found")` -- 404, code "NOT_FOUND"
- `rateLimited(retryAfterSeconds: number)` -- 429, code "RATE_LIMITED", message includes retry time. Return with `Retry-After` header.
- `serviceUnavailable(message: string)` -- 503, code "SERVICE_UNAVAILABLE"
- `internalError(message = "An unexpected error occurred.")` -- 500, code "INTERNAL_ERROR"
- `aiError(message = "AI service error. Please try again.")` -- 502, code "AI_ERROR"
- `storageError(message = "Storage operation failed.")` -- 500, code "STORAGE_ERROR"

Import NextResponse from "next/server".

**Error code catalog** (document in a comment at the top):
| Code | HTTP | When |
|------|------|------|
| INVALID_JSON | 400 | Body is not valid JSON |
| VALIDATION_ERROR | 400 | Zod/input validation failed |
| UNAUTHORIZED | 401 | Missing or invalid auth |
| NOT_FOUND | 404 | Resource not found |
| RATE_LIMITED | 429 | Rate limit exceeded |
| SERVICE_UNAVAILABLE | 503 | Missing API key or config |
| AI_ERROR | 502 | Claude/external API failure |
| STORAGE_ERROR | 500 | KV/Blob operation failed |
| INTERNAL_ERROR | 500 | Unknown error |
  </action>
  <verify>
1. Read the file and confirm all exports: AppError, ApiErrorResponse, errorResponse, badRequest, unauthorized, notFound, rateLimited, serviceUnavailable, internalError, aiError, storageError
2. Run `npx tsc --noEmit` to verify no TypeScript errors
  </verify>
  <done>
- api-errors.ts exports AppError class with code, message, statusCode, details
- api-errors.ts exports errorResponse helper and 8 convenience functions
- All error responses use consistent shape: { error: { code, message, details? } }
- rateLimited includes Retry-After header
- TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create withApiHandler wrapper and Zod validation schemas</name>
  <files>src/lib/api-handler.ts, src/lib/validation.ts</files>
  <action>
**Part A: Create `src/lib/api-handler.ts`**

Create a higher-order function `withApiHandler` that wraps API route handlers:

```typescript
interface HandlerOptions<T> {
  schema?: z.ZodType<T>;        // Zod schema for body validation
  bodyType?: "json" | "none";   // "none" for GET/DELETE or FormData routes; default "json"
  maxBodySize?: number;          // Optional body size limit (future use)
}

export function withApiHandler<T = unknown>(
  handler: (request: NextRequest, body: T) => Promise<NextResponse>,
  options: HandlerOptions<T> = {}
): (request: NextRequest) => Promise<NextResponse>
```

The wrapper should:
1. Wrap the entire handler in try/catch
2. For POST/PUT/PATCH with `bodyType !== "none"`:
   - Parse JSON body with try/catch (throw AppError "INVALID_JSON" on failure)
   - If `schema` provided, run `schema.safeParse(rawBody)`. On failure, throw AppError "VALIDATION_ERROR" with `details` containing an array of `{ path: string, message: string }` from Zod issues
   - Pass validated body to handler
3. For GET/DELETE or `bodyType: "none"`:
   - Pass `undefined as T` to handler (handler can read query params from request directly)
4. Catch errors:
   - `AppError` instances: return structured error response using errorResponse()
   - `z.ZodError` instances: return VALIDATION_ERROR with issues
   - Unknown errors: `console.error("[API Error]", error)`, return INTERNAL_ERROR with generic message. NEVER leak `error.message` to client.

Import AppError and error helpers from `./api-errors`. Import z from "zod". Import NextRequest/NextResponse from "next/server".

**Part B: Create `src/lib/validation.ts`**

Create Zod schemas for all 13 API route inputs. Read each route.ts to understand the current manual validation and derive appropriate schemas. Use Zod v4 syntax (error param, not message).

Schemas to create (examine each route for field names, types, and constraints):

1. `AuthLoginSchema` -- { password: z.string().min(1) }
2. `DecomposeInputSchema` -- { description: z.string().min(1).max(15000), stages: array of objects (optional), context: z.string().max(5000).optional(), parentId: z.string().optional(), costContext: object (optional) }. The stages field currently accepts objects with name/owner/tools/inputs/outputs -- match the existing DecomposeRequest type structure. The costContext has hourlyRate (number), hoursPerStep (number), teamSize (int), teamContext (string max 200).
3. `WorkflowSaveSchema` -- Validate the Workflow type structure. At minimum: { id: z.string().min(1), decomposition: z.object({...}).passthrough(), description: z.string(), createdAt: z.string(), updatedAt: z.string() }. Use `.passthrough()` on complex nested objects to avoid breaking existing data shapes while still validating the outer structure.
4. `WorkflowDeleteParamsSchema` -- { id: z.string().min(1) } (for query param validation)
5. `CompareSchema` -- { before: z.record(z.string(), z.unknown()), after: z.record(z.string(), z.unknown()) }
6. `RemediationInputSchema` -- Read the remediation route to determine fields. Likely { workflowId: z.string(), gaps: z.array(...), decomposition: z.object({}).passthrough() } or similar.
7. `NotionImportSchema` -- { notionUrl: z.string().url() } or { pageId: z.string() } -- check the route
8. `NotionSyncSchema` -- Read the route for shape. Likely contains a workflow object.
9. `RemediationNotionSyncSchema` -- Read the route for shape. Contains plan + gaps.
10. `ExtractWorkflowsSchema` -- { content: z.string().min(1).max(50000) } or similar -- check route
11. `ExtractFromScreenshotSchema` -- { image: z.string().min(1) } (base64) -- check route
12. `ScrapeUrlSchema` -- { url: z.string().url() } -- check route
13. `CrawlSiteSchema` -- { url: z.string().url(), maxPages: z.number().int().min(1).max(50).optional() } -- check route
14. `ParseFileMetaSchema` -- For post-FormData-extraction validation: { fileName: z.string(), fileType: z.string(), content: z.string() } -- check route

Export all schemas and their inferred types using `z.infer<typeof SchemaName>`.

**Important Zod v4 notes:**
- Use `{ error: "message" }` not `{ message: "message" }` for custom error messages
- Use `.extend()` not `.merge()` for combining objects
- `z.string().email()` still works
- `.int()` validates safe integers only
  </action>
  <verify>
1. Read api-handler.ts -- confirm withApiHandler exports, handles AppError/ZodError/unknown errors, parses body for POST
2. Read validation.ts -- confirm all 14 schemas export with z.infer types
3. Run `npx tsc --noEmit` to verify no TypeScript errors
4. Grep validation.ts for "z.string()" to confirm Zod usage (not manual typeof)
  </verify>
  <done>
- withApiHandler wraps handlers with structured error catching (AppError, ZodError, unknown)
- withApiHandler parses and validates JSON body for POST/PUT/PATCH when schema provided
- withApiHandler supports bodyType: "none" for GET/DELETE/FormData routes
- Unknown errors are logged but NEVER leak err.message to client
- validation.ts exports Zod schemas for all 13 API route inputs
- All schemas use Zod v4 syntax
- TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- api-errors.ts: All error codes documented, convenience helpers exported
- api-handler.ts: withApiHandler exports, catches all three error types
- validation.ts: 14+ schema exports covering all routes
- No files from Plan 01 are modified (exclusive file ownership)
</verification>

<success_criteria>
1. AppError thrown anywhere in a wrapped handler produces { error: { code, message, details? } } JSON
2. Unknown errors produce generic INTERNAL_ERROR without leaking internals
3. Zod validation failures produce VALIDATION_ERROR with per-field details
4. Every API route has a corresponding Zod schema ready for use
5. TypeScript compiles cleanly with all new files
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-security/01-02-SUMMARY.md`
</output>
