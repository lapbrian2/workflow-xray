---
phase: 01-infrastructure-security
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/app/api/auth/route.ts
  - src/app/api/decompose/route.ts
  - src/app/api/workflows/route.ts
  - src/app/api/compare/route.ts
  - src/app/api/remediation/route.ts
  - src/app/api/notion-import/route.ts
  - src/app/api/notion-sync/route.ts
autonomous: true

must_haves:
  truths:
    - "All 7 routes return errors in { error: { code, message, details? } } shape"
    - "All 7 routes validate input with Zod schemas before processing"
    - "No route in this batch leaks err.message to the client"
    - "Rate limiting still works on routes that had it"
    - "Existing route behavior (success paths) is preserved"
  artifacts:
    - path: "src/app/api/auth/route.ts"
      provides: "Auth login/logout with structured errors + Zod validation"
      exports: ["POST", "DELETE"]
    - path: "src/app/api/decompose/route.ts"
      provides: "Workflow decomposition with Zod-validated input + structured errors"
      exports: ["POST"]
    - path: "src/app/api/workflows/route.ts"
      provides: "Workflow CRUD with structured errors + Zod validation on POST"
      exports: ["GET", "POST", "DELETE"]
    - path: "src/app/api/compare/route.ts"
      provides: "Workflow comparison with Zod-validated input"
      exports: ["POST"]
    - path: "src/app/api/remediation/route.ts"
      provides: "Remediation plan generation with structured errors"
      exports: ["POST", "GET"]
    - path: "src/app/api/notion-import/route.ts"
      provides: "Notion import with Zod-validated input"
      exports: ["POST"]
    - path: "src/app/api/notion-sync/route.ts"
      provides: "Notion sync with Zod-validated input"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/*/route.ts"
      to: "src/lib/api-handler.ts"
      via: "import withApiHandler"
      pattern: "import.*withApiHandler.*from.*api-handler"
    - from: "src/app/api/*/route.ts"
      to: "src/lib/validation.ts"
      via: "import route-specific schema"
      pattern: "import.*Schema.*from.*validation"
---

<objective>
Migrate 7 standard API routes to use withApiHandler + Zod validation schemas -- the first batch covering auth, decompose, workflows, compare, remediation, notion-import, and notion-sync (INFR-03 + INFR-04).

Purpose: These 7 routes all use standard JSON body parsing and can be mechanically migrated to the wrapper pattern. This eliminates their manual typeof checks, inconsistent error shapes, and err.message leaks.
Output: 7 routes refactored to use withApiHandler with Zod schemas, all returning consistent structured error responses.
</objective>

<execution_context>
@C:/Users/Brian/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Brian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-security/01-RESEARCH.md
@.planning/phases/01-infrastructure-security/01-02-SUMMARY.md

@src/lib/api-handler.ts
@src/lib/api-errors.ts
@src/lib/validation.ts
@src/lib/rate-limit.ts
@src/app/api/auth/route.ts
@src/app/api/decompose/route.ts
@src/app/api/workflows/route.ts
@src/app/api/compare/route.ts
@src/app/api/remediation/route.ts
@src/app/api/notion-import/route.ts
@src/app/api/notion-sync/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate auth, decompose, and workflows routes to withApiHandler</name>
  <files>src/app/api/auth/route.ts, src/app/api/decompose/route.ts, src/app/api/workflows/route.ts</files>
  <action>
Migrate these 3 routes to use `withApiHandler` from `@/lib/api-handler` and Zod schemas from `@/lib/validation`. For each route:

**Migration pattern:**
1. Import `withApiHandler` from `@/lib/api-handler`
2. Import the route's Zod schema from `@/lib/validation`
3. Import `AppError` from `@/lib/api-errors` for throwing structured errors within the handler
4. Wrap the exported handler function with `withApiHandler(handler, { schema: RouteSchema })`
5. Remove manual try/catch (the wrapper handles it)
6. Remove manual body parsing (`request.json()`) -- the wrapper does this
7. Remove manual typeof validation -- Zod schema handles it
8. Replace inline `NextResponse.json({ error: "string" }, { status })` with `throw new AppError(code, message, status)`
9. Keep rate limiting logic -- either integrate it before the wrapper call or move it inside the handler (throwing AppError for rate limits). The simplest approach: keep the rate limit check as the first line inside the handler and throw `new AppError("RATE_LIMITED", message, 429)` if blocked. OR use the existing `rateLimit` function and return the structured error directly.

**Route-specific notes:**

**auth/route.ts (POST + DELETE):**
- POST: Wrap with `withApiHandler(handler, { schema: AuthLoginSchema })`
- The validated body will have `{ password: string }`
- Keep the `isAuthEnabled()` check -- throw `AppError("SERVICE_UNAVAILABLE", "Authentication is not configured.", 503)`
- Keep the rate limiting -- throw `AppError("RATE_LIMITED", ...)` if not allowed
- Keep the hash comparison and cookie setting (success path unchanged)
- DELETE: Wrap with `withApiHandler(handler, { bodyType: "none" })` -- no body needed

**decompose/route.ts (POST):**
- Wrap with `withApiHandler(handler, { schema: DecomposeInputSchema })`
- Remove ALL manual validation (typeof checks, length checks for description, stages filter/slice)
- The Zod schema handles: description required + max 15000, stages as optional array with field constraints, context max 5000, parentId optional, costContext optional
- Keep the `ANTHROPIC_API_KEY` check -- throw `AppError("SERVICE_UNAVAILABLE", "API key not configured.", 503)`
- Keep rate limiting -- throw AppError
- Keep the enrichedDescription team context block (reads from validated body.costContext)
- In the catch block for decomposeWorkflow errors: throw `AppError("AI_ERROR", userFriendlyMessage, 502)` instead of returning raw NextResponse
- IMPORTANT: The current route has sophisticated error message mapping (timeout, rate limit, JSON parse, schema validation). Preserve this logic by catching errors from `decomposeWorkflow()` in a nested try/catch within the handler, then re-throwing as AppError with appropriate codes.

**workflows/route.ts (GET + POST + DELETE):**
- GET: Wrap with `withApiHandler(handler, { bodyType: "none" })`. Read search/id from query params inside handler. Throw `AppError("NOT_FOUND", ...)` when workflow not found.
- POST: Wrap with `withApiHandler(handler, { schema: WorkflowSaveSchema })`. The validated body replaces `await request.json()`.
- DELETE: Wrap with `withApiHandler(handler, { bodyType: "none" })`. Read id from query params. Throw `AppError("VALIDATION_ERROR", "ID is required", 400)` when missing.
- Keep rate limiting on all three -- throw AppError

**For all routes:** Ensure the success response shapes remain UNCHANGED. Only error responses change shape.
  </action>
  <verify>
1. Grep all 3 route files for `withApiHandler` -- each should import and use it
2. Grep for `{ error: "` (old error shape) -- should find ZERO matches in these files
3. Grep for `AppError` -- should find usage in each file
4. Run `npx tsc --noEmit` to verify no TypeScript errors
5. Confirm that success response shapes are preserved (NextResponse.json with original data shapes)
  </verify>
  <done>
- auth/route.ts: POST uses withApiHandler + AuthLoginSchema, DELETE uses withApiHandler with bodyType none
- decompose/route.ts: Uses withApiHandler + DecomposeInputSchema, all manual validation removed
- workflows/route.ts: GET/POST/DELETE all use withApiHandler, POST uses WorkflowSaveSchema
- All error responses use { error: { code, message, details? } } shape
- All success responses unchanged
- Rate limiting preserved via AppError throws
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate compare, remediation, notion-import, and notion-sync routes</name>
  <files>src/app/api/compare/route.ts, src/app/api/remediation/route.ts, src/app/api/notion-import/route.ts, src/app/api/notion-sync/route.ts</files>
  <action>
Apply the same migration pattern as Task 1 to these 4 routes. For each:
1. Import `withApiHandler` from `@/lib/api-handler`
2. Import the route's Zod schema from `@/lib/validation`
3. Import `AppError` from `@/lib/api-errors` for in-handler error throwing
4. Wrap exports with `withApiHandler`
5. Remove manual try/catch, body parsing, typeof validation
6. Replace `{ error: "string" }` responses with AppError throws

**Route-specific notes:**

**compare/route.ts (POST):**
- Read the existing route to understand current validation
- Wrap with `withApiHandler(handler, { schema: CompareSchema })`
- Replace any `{ error: "string" }` responses with AppError throws
- Keep rate limiting if present

**remediation/route.ts (POST + GET):**
- POST: Wrap with `withApiHandler(handler, { schema: RemediationInputSchema })`. This route already uses Zod for OUTPUT validation (Claude response parsing). Keep that. Only replace INPUT validation with the schema.
- GET: Wrap with `withApiHandler(handler, { bodyType: "none" })`. Read query params inside handler.
- Check for `ANTHROPIC_API_KEY` -- throw `AppError("SERVICE_UNAVAILABLE", ...)`
- Keep rate limiting

**notion-import/route.ts (POST):**
- Wrap with `withApiHandler(handler, { schema: NotionImportSchema })`
- Replace manual typeof checks with Zod validation
- Keep rate limiting if present
- External service errors (Notion API failures): catch and throw `AppError("AI_ERROR", sanitizedMessage, 502)` or appropriate code

**notion-sync/route.ts (POST):**
- Wrap with `withApiHandler(handler, { schema: NotionSyncSchema })`
- This route receives a complex workflow object -- the schema should validate outer structure with `.passthrough()` on deeply nested objects
- Keep rate limiting if present
- External service errors: catch and throw appropriate AppError

**For all routes:**
- NEVER pass `err.message` directly to AppError message -- always use a sanitized/user-friendly message
- Log the original error with `console.error` before throwing AppError
- Preserve all success response shapes exactly as-is
  </action>
  <verify>
1. Grep all 4 route files for `withApiHandler` -- each should import and use it
2. Grep for `{ error: "` (old error shape) -- should find ZERO matches in these files
3. Run `npx tsc --noEmit` to verify no TypeScript errors
4. Confirm all success response shapes are preserved
  </verify>
  <done>
- compare/route.ts: Uses withApiHandler + CompareSchema
- remediation/route.ts: POST uses RemediationInputSchema, GET uses bodyType none
- notion-import/route.ts: Uses withApiHandler + NotionImportSchema
- notion-sync/route.ts: Uses withApiHandler + NotionSyncSchema
- All error responses use structured shape
- All success responses unchanged
- No err.message leaked to client
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Grep across all 7 route files: every file imports `withApiHandler`
- Grep across all 7 route files: zero instances of `{ error: "` (old flat error shape)
- Grep across all 7 route files: zero instances of `err.message` or `error.message` in response bodies (only in console.error)
- Existing rate limiting still present (grep for `rateLimit` in auth, decompose, workflows)
</verification>

<success_criteria>
1. All 7 routes use withApiHandler wrapper
2. All 7 routes validate input with Zod schemas (POST routes)
3. All error responses follow { error: { code, message, details? } } shape
4. No route leaks internal error messages to clients
5. Success response shapes unchanged (backward compatible)
6. Rate limiting preserved on routes that had it
7. TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-security/01-03-SUMMARY.md`
</output>
